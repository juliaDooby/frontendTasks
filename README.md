// --------------------------------------------------------------------------------------------
// [Базовые Задачи]:
// ---------------------
// - массивы,
// -  объекты,
// - сортировки,
// - события,
// - браузер API)
// - Сумма элементов массива. №1, №2, №3.
// - Максимальный / минимальный элемент массива. №1, №2
// - Максимальный / минимальный элемент массива. Вариации первого способа.
// - Максимальный / минимальный элемент массива. №2.
// - Максимальный / минимальный элемент массива. №3.
// - Максимальный / минимальный элемент массива. №4.
// - Сортировка массива.
// - Сортировка массива с объектами по их полям (по алфавиту и по возрастанию).
// - Развернуть массив без .reverse().
// - Отфильтровать falsy значения
// - Задания со строками + Примитивы;
// - Суммы элементов массива + array flat;
// - Задача на Timeout внутри цикла;
// - Задача на асинхронность + eventLoop;
// - Как написать зарос на сервер xmlhttprequest и fetch;
// - Написать свой Promise.all(); - Сумма элементов через замыкание;
// - Интеграция
// - Уникальность всех символов в строке
// - Плоский массив
// - Удаление всех повторяющихся значения в строке
// - Какая строка встречается чаще всего
// - Повернута ли строка?
// - Является ли массив подмножеством другого массива
// - Анаграммы
// - Перевернуть матрицу 3х3
// - Простой поиск
// - Сбалансированные скобки
// - Очередь с О(1) сложностью операций
// - Deep Equal
// - Последовательность Фибоначчи
// - Своя функция bind
// - Универсальная сумма
// - GroupBy
// - + - Числа Фибоначчи - РЕКУРСИЯ
// - Числа Фибоначчи - Итеративный способ
// - Палиндром
// - Задача на понимание замыканий\колбеков
// - Задача с концертами
// - Периметр закрашенной области
// - Задачи с числами и массивом
// - Обход n-го дерево
// - Объединить отсорт. масссивы, найти простые числа в массиве, конвертировать цену, написать калькультор
// - алгоритмы из яндекса
// - моки
// -----
// Эти задачи могут варьироваться в зависимости от требований к конкретной позиции и уровня сложности, но обычно они направлены на оценку вашего понимания основ React.js и вашей способности создавать простые компоненты и приложения на его основе.
// ⋙ ❍ Рендеринг компонентов:
// Задача: Создать компонент, который рендерит простой текстовый элемент.
// Ожидаемый результат: Простой компонент, который выводит текст на экран.
// ⋙ ❍ Управление состоянием компонентов:
// Задача: Создать компонент, который изменяет свое состояние при нажатии на кнопку.
// Ожидаемый результат: Компонент с кнопкой, при нажатии на которую меняется его состояние.
// ⋙ ❍ Передача пропсов в компоненты:
// Задача: Создать компонент, который принимает пропсы и выводит их значение.
// Ожидаемый результат: Компонент, который принимает пропсы и отображает их значение на экране.
// ⋙ ❍ Использование жизненного цикла компонентов:
// Задача: Создать компонент, который выполняет определенные действия при монтировании и размонтировании.
// Ожидаемый результат: Компонент, который выполняет определенные действия при монтировании и размонтировании, например, выводит сообщение в консоль.
// ⋙ ❍ Работа с формами:
// Задача: Создать компонент формы, который обрабатывает введенные пользователем данные.
// Ожидаемый результат: Компонент формы, который обрабатывает введенные данные и отправляет их на сервер или выполняет другие действия.
// ⋙ ❍ Работа с API:
// Задача: Создать компонент, который получает данные с сервера через API и отображает их на экране.
// Ожидаемый результат: Компонент, который загружает данные с сервера и отображает их на странице.
// ⋙ ❍ Использование сторонних библиотек и компонентов:
// Задача: Использовать стороннюю библиотеку или компонент для выполнения определенной функциональности.
// Ожидаемый результат: Использование сторонней библиотеки или компонента для добавления дополнительной функциональности в приложение.
// ---------------------------------------------------------------------------------------------
// [ПРАКТИЧЕСКИЕ ЗАДАЧИ MIDDLE/SENIOR В ОДНОМ ИЗВЕСТНОМ БАНКЕ ✅]:
// ---------------------
// ⋙ ❍ Методы Promise (Promise.all, Promise.allSettled, Promise.race)? ✔
// 1. Promise.all(): Этот метод принимает массив промисов и возвращает один промис, который выполнится, когда все промисы в массиве будут выполнены успешно. Если хотя бы один из промисов завершится ошибкой, то возвращаемый промис будет завершен с этой ошибкой.
// Пример использования:
// ```javascript
// const promise1 = Promise.resolve(3);
// const promise2 = 42;
// const promise3 = new Promise((resolve, reject) => {
//   setTimeout(resolve, 100, 'foo');
// });

// Promise.all([promise1, promise2, promise3]).then((values) => {
//   console.log(values); // [3, 42, "foo"]
// });
// ```
// 2. Promise.allSettled(): Этот метод принимает массив промисов и возвращает один промис, который выполнится, когда все промисы в массиве будут завершены, независимо от их состояния (успешно или с ошибкой). Возвращаемый промис будет разрешен массивом объектов, представляющих результаты каждого промиса. Каждый объект будет иметь свойство `status`, которое будет иметь значение `"fulfilled"` для успешных промисов и `"rejected"` для промисов с ошибкой, а также свойство `value`, содержащее результат успешного промиса или `reason` с описанием ошибки.
// Пример использования:
// ```javascript
// const promise1 = Promise.resolve(3);
// const promise2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'Ошибка'));
// const promise3 = new Promise((resolve, reject) => setTimeout(resolve, 200, 'foo'));

// Promise.allSettled([promise1, promise2, promise3]).then((results) => {
//   console.log(results);
//   // [
//   //   { status: "fulfilled", value: 3 },
//   //   { status: "rejected", reason: "Ошибка" },
//   //   { status: "fulfilled", value: "foo" }
//   // ]
// });
// ```
// 3. Promise.race(): Этот метод принимает массив промисов и возвращает промис, который разрешится или отклонится с тем результатом, который разрешится или отклонится первым в массиве промис. То есть, если хотя бы один промис завершится (успешно или с ошибкой), возвращаемый промис тоже завершится соответственно.
// Пример использования:
// ```javascript
// const promise1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'one'));
// const promise2 = new Promise((resolve, reject) => setTimeout(resolve, 100, 'two'));

// Promise.race([promise1, promise2]).then((value) => {
//   console.log(value); // 'two'
// });
// ```
// Эти методы позволяют эффективно управлять потоком выполнения промисов, особенно в случае, когда необходимо дождаться выполнения нескольких асинхронных операций или реагировать на первую завершившуюся операцию.
// -----
// ⋙ ❍ Задача. Дан массив [1,1,1,2,4,5]. Нужно вернуть true в случае если в нём есть хотя бы один повторяющийся элемент? ✔
// Для решения этой задачи можно использовать различные подходы, но одним из самых простых способов является использование хэш-таблицы для отслеживания уникальных элементов массива.
// Вот пример JavaScript-кода, который решает задачу:
// ```javascript
// function hasDuplicate(arr) {
//   // Создаем объект для отслеживания уникальных элементов
//   const seen = {};

//   // Проходим по каждому элементу массива
//   for (let i = 0; i < arr.length; i++) {
//     // Если текущий элемент уже был ранее добавлен в объект,
//     // значит, у нас есть повторяющийся элемент
//     if (seen[arr[i]]) {
//       return true;
//     } else {
//       // Иначе помечаем текущий элемент как присутствующий в массиве
//       seen[arr[i]] = true;
//     }
//   }

//   // Если цикл завершился, и повторяющихся элементов не найдено
//   return false;
// }

// // Пример использования:
// const arr = [1, 1, 1, 2, 4, 5];
// console.log(hasDuplicate(arr)); // Выведет: true
// ```
// Этот код создает объект `seen`, где ключами являются элементы массива, а значениями - логические значения, указывающие на то, встречался ли элемент ранее. Если элемент уже присутствует в объекте `seen`, значит, у нас есть повторяющийся элемент, и функция возвращает `true`. Если цикл завершится без обнаружения повторяющихся элементов, функция вернет `false`.
// -----
// ⋙ ❍ Рассказать о Map и Set? ✔
// Map:
// Map - это коллекция ключ-значение, где каждый элемент представляет собой пару ключ-значение. Она предоставляет удобные методы для добавления, удаления и поиска элементов по ключу. Ключи могут быть любого типа, включая примитивные типы данных, объекты и функции.
// Основные методы Map:
// - `set(key, value)`: Добавляет новый элемент с указанным ключом и значением.
// - `get(key)`: Возвращает значение, соответствующее указанному ключу.
// - `has(key)`: Проверяет наличие элемента с указанным ключом в Map.
// - `delete(key)`: Удаляет элемент с указанным ключом из Map.
// - `clear()`: Удаляет все элементы из Map.
// - `size`: Возвращает количество элементов в Map.
// Пример использования Map:
// ```javascript
// let map = new Map();

// map.set('name', 'John');
// map.set(1, 'One');
// map.set({}, 'Object');

// console.log(map.get('name')); // Выведет: John
// console.log(map.has(1));      // Выведет: true
// map.delete('name');
// console.log(map.size);        // Выведет: 2
// ```
// Set:
// Set - это коллекция уникальных значений, где каждое значение может присутствовать только один раз. Она предоставляет методы для добавления, удаления и проверки наличия значений в коллекции.
// Основные методы Set:
// - `add(value)`: Добавляет новое значение в коллекцию.
// - `has(value)`: Проверяет наличие значения в коллекции.
// - `delete(value)`: Удаляет значение из коллекции.
// - `clear()`: Удаляет все значения из коллекции.
// - `size`: Возвращает количество элементов в Set.
// Пример использования Set:
// ```javascript
// let set = new Set();

// set.add(1);
// set.add(2);
// set.add(2); // Этот вызов игнорируется, так как 2 уже есть в коллекции

// console.log(set.has(1)); // Выведет: true
// set.delete(1);
// console.log(set.size);   // Выведет: 1
// ```
// Ключевая особенность Set - это то, что она хранит только уникальные значения, поэтому любое значение может быть добавлено в коллекцию только один раз. Это делает Set удобным инструментом для удаления дубликатов из массивов или других коллекций.
// -----
// ⋙ ❍ Если есть проект с ограниченными сроками и некритичной производительностью, чем будете руководствоваться при выборе библиотек, подходов? Или все же будете обращать внимание на производительность? Или наоборот: сроки нелимитированные, производительность важна. Ваши действия? ✔
// При выборе библиотек, подходов и инструментов для проекта, где есть ограниченные сроки и некритичная производительность, или наоборот, где сроки нелимитированные, но производительность важна, следует учитывать несколько факторов:
// 1. Сроки проекта:
// - Если у вас ограниченные сроки, то целью является быстрое достижение результатов. В этом случае стоит выбирать инструменты и библиотеки, с которыми вы уже знакомы или которые имеют хорошую документацию и поддержку, чтобы сократить время на обучение и разработку.
// - Если сроки нелимитированные, вы можете позволить себе больше времени на изучение и выбор оптимальных инструментов.
// 2. Производительность:
// - Если производительность не является критическим фактором для проекта, вы можете отдать предпочтение инструментам и подходам, которые обеспечивают простоту разработки и поддержки, даже если они менее эффективны с точки зрения производительности.
// - Если производительность имеет высокий приоритет, необходимо выбирать библиотеки и подходы, которые предлагают оптимальную производительность и эффективное использование ресурсов.
// 3. Опыт команды:
// - Учитывайте опыт и знания вашей команды разработчиков. Если у вас есть опытные специалисты по конкретным технологиям или инструментам, то выбор этих технологий может ускорить разработку и повысить качество проекта.
// 4. Требования проекта:
// - Важно учитывать требования и характеристики проекта при выборе библиотек и подходов. Например, если проект требует обширного взаимодействия с базой данных, то важно выбрать соответствующую ORM или библиотеку для работы с данными.
// В целом, при выборе подходов и инструментов для проекта важно учитывать баланс между сроками, производительностью, опытом команды и требованиями проекта. Каждый проект уникален, поэтому не существует универсального решения, и рекомендуется принимать решения на основе конкретных условий и потребностей проекта.
// -----
// ⋙ ❍ Какие состояния имеет Promise и что они обозначают (речь о pending, fulfilled, rejected)? ✔
// Promise может находиться в одном из трех состояний:
// 1. Pending (ожидание): Начальное состояние промиса. Это означает, что асинхронная операция, обещанная промисом, все еще выполняется, и результат еще неизвестен. Промис может перейти из состояния ожидания только в состояние "выполнен" или "отклонен".
// 2. Fulfilled (выполнен): Это состояние, в котором промис успешно завершился. Если промис перешел в это состояние, это означает, что асинхронная операция, обещанная промисом, завершилась успешно, и результат доступен. Если промис находится в этом состоянии, то у него есть значение, доступное через функцию обратного вызова `then`.
// 3. Rejected (отклонен): Это состояние, в котором промис завершился с ошибкой. Если промис перешел в это состояние, это означает, что асинхронная операция, обещанная промисом, завершилась с ошибкой, и результат недоступен. Если промис находится в этом состоянии, у него есть причина отклонения, доступная через функцию обратного вызова `catch`.
// Важно отметить, что промисы являются неизменяемыми, поэтому после того, как промис перешел в состояние "выполнен" или "отклонен", он остается в этом состоянии и не может перейти в другое состояние или изменить свое значение.
// -----
// ⋙ ❍ Рассказать про основные этапы рендера страницы. Какие ресурсы блокируют парсинг, а какие нет. Чем отличается async от defer. Этапы рендера (DOM/CSSOM, Render Tree, Layout, Paint) ✔
// Основные этапы рендера страницы в браузере включают в себя:
// 1. Парсинг HTML/DOM (Document Object Model): Браузер начинает с загрузки и парсинга HTML-документа, создавая DOM (Document Object Model) - древовидное представление структуры HTML-документа.
// /Создается древовидная структура HTML-документа, представляющая его структуру и содержимое.
// 2. Парсинг CSS/CSSOM (CSS Object Model): После того как браузер встречает тег `<link>` или `<style>`, он начинает загружать и парсить CSS-файлы, создавая CSSOM (CSS Object Model) - древовидное представление стилей CSS.
// /Создается древовидная структура стилей CSS, описывающая внешний вид элементов на странице.
// 3. Формирование Render Tree (Дерево отображения): Браузер объединяет DOM и CSSOM, чтобы создать Render Tree - древовидное представление того, как элементы будут отображаться на экране. Этот этап включает только элементы, которые отображаются на странице, игнорируя скрытые элементы.
// /Комбинируются DOM и CSSOM для создания Render Tree, который представляет, как элементы будут отображаться на экране.
// 4. Layout (Отображение/Разметка): Браузер вычисляет геометрию каждого элемента, располагая их в окне просмотра и определяя их размеры и позиции относительно других элементов. Этот этап также называется "reflow".
// /Браузер вычисляет размеры и позиции элементов в Render Tree и определяет, как они будут располагаться на странице.
// 5. Paint (Отрисовка): На основе Render Tree и Layout, браузер начинает отрисовывать пиксели на экране, создавая окончательное изображение страницы.
// /Браузер отрисовывает каждый элемент Render Tree на экране, создавая окончательное изображение страницы.
// Ресурсы, которые блокируют парсинг HTML, включают в себя:
// - Внешние CSS-файлы, загружаемые с помощью тега `<link>`.
// - JavaScript файлы, загружаемые с помощью тега `<script>`, без атрибутов `async` или `defer`.
// Ресурсы, которые не блокируют парсинг HTML:
// - Встроенные (Inline) CSS.
// - Внешние CSS-файлы, загружаемые с помощью атрибутов `async` или `defer` в теге `<link>`.
// - JavaScript файлы, загружаемые с помощью атрибутов `async` или `defer` в теге `<script>`.
// Отличие между `async` и `defer`:
// - async: Браузер загружает скрипт параллельно с парсингом HTML и выполняет его сразу после загрузки, без ожидания полной загрузки документа. Порядок выполнения скриптов не гарантирован.
// - defer: Браузер загружает скрипт параллельно с парсингом HTML, но откладывает его выполнение до завершения парсинга и построения DOM. Скрипты выполняются в том порядке, в котором они появляются в документе.
// -----
// ⋙ ❍ Как можно оптимизировать страницу (не блокирующие скрипты, минификация CSS/JS, сжатие изображений, указание размеров изображений, фолбеки для шрифта, выделение critical CSS) ✔
// 1. Неблокирующие скрипты: Выполняйте скрипты асинхронно или отложено (`async` или `defer`), чтобы они не блокировали загрузку других ресурсов и рендеринг страницы.
// /Используйте атрибуты `async` или `defer` для скриптов, чтобы они не блокировали загрузку страницы.
// 2. Минификация CSS/JS: Уменьшайте размер CSS и JavaScript файлов путем удаления пробелов, комментариев и сокращения имен переменных. Это поможет ускорить загрузку страницы.
// 3. Сжатие изображений: Используйте сжатие изображений (например, с помощью инструментов сжатия изображений или форматов изображений с потерями, таких как JPEG), чтобы уменьшить размер файлов и время загрузки страницы.
// /Сжимайте изображения для уменьшения их размера без потери качества.
// 4. Указание размеров изображений: Укажите размеры изображений в HTML с помощью атрибутов `width` и `height`, чтобы браузер мог выделить место под изображение до его полной загрузки, предотвращая скачки макета.
// /Укажите размеры изображений в HTML для предотвращения скачков макета страницы.
// 5. Фолбеки для шрифтов: Укажите альтернативные шрифты и фолбеки в CSS, чтобы браузер мог отображать текст, даже если первоначальный шрифт не загружен.
// /Установите альтернативные шрифты, которые будут отображаться, если первоначальный шрифт не загружен.
// 6. Выделение critical/критического CSS: Определите критический CSS (CSS, необходимый для первоначального рендеринга видимой части страницы) и встраивайте его непосредственно в HTML или загружайте его внутри `<style>` тега в `<head>`. Это ускоряет начальное отображение страницы.
// /Определите и встраивайте критический CSS, необходимый для первоначального рендеринга видимой части страницы.
// 7. Кэширование ресурсов: Установите правильные заголовки кэширования на сервере, чтобы браузеры могли кэшировать статические ресурсы, такие как CSS, JavaScript и изображения, и избежать повторной загрузки при последующих посещениях.
// 8. Ленивая загрузка ресурсов: Используйте ленивую загрузку (например, с помощью атрибута `loading="lazy"` для изображений или динамического импорта для JavaScript), чтобы отложить загрузку ресурсов, которые не отображаются при первоначальной загрузке страницы.
// 9. Использование CDN: Используйте Content Delivery Network (CDN), чтобы ускорить загрузку статических ресурсов, таких как CSS, JavaScript и изображения, путем размещения их на серверах, распределенных по всему миру.
// Применение этих методов поможет оптимизировать загрузку и производительность вашей веб-страницы, что улучшит пользовательский опыт и может повысить ее рейтинг в поисковых системах.
// -----
// ⋙ ❍ Какие CSS-свойства влияют на производительность (преимущество transform: translate перед margin) ✔
// Влияние CSS-свойств на производительность зависит от того, как браузер обрабатывает их при рендеринге и перерисовке страницы. Некоторые свойства могут вызывать больше нагрузки на процессор и GPU, поэтому оптимизация этих свойств может улучшить производительность вашего веб-приложения.
// Некоторые из ключевых CSS-свойств, которые могут повлиять на производительность, включают:
// 1. Positioning (позиционирование): Использование свойств `position`, `top`, `left`, `right`, `bottom` может вызывать перерасчеты позиции элементов и перерисовку страницы при каждом изменении, что может быть нагружающим для производительности. Использование `transform` может быть более эффективным, поскольку оно не вызывает перерасчетов макета страницы.
// 2. Анимации и переходы: Использование CSS-анимаций и переходов с большим количеством элементов или с большими значениями свойств, такими как `width`, `height`, `top`, `left`, может сказаться на производительности. Вместо этого рекомендуется использовать анимации с помощью `transform` и `opacity`, так как они выполняются на GPU и могут быть более эффективными.
// 3. Изменение размеров элементов: Изменение размеров элементов с помощью свойств `width` и `height` может вызывать перерасчеты макета страницы. Вместо этого рекомендуется использовать `transform: scale`, чтобы масштабировать элементы, поскольку это также выполняется на GPU.
// 4. Прозрачность: Использование свойства `opacity` может вызвать рендеринг элементов с альфа-каналом, что может быть нагружающим для производительности. Вместо этого рекомендуется использовать `opacity` вместе с `transform: translateZ(0)`, чтобы элементы были рендерены на GPU.
// Таким образом, важно выбирать CSS-свойства, которые могут оптимизировать производительность вашего веб-приложения, особенно при работе с анимациями и динамическими изменениями макета страницы. Использование свойства `transform` вместо `margin` может быть одним из таких способов оптимизации.
// -----
// ⋙ ❍ Что такое O-большое? ✔
// O-большое (Big O notation) - это математическая нотация, используемая в информатике, чтобы оценивать асимптотическое поведение функции, описывающей скорость роста времени выполнения или потребляемой памяти алгоритма. Она помогает определить, насколько быстро алгоритм будет работать при увеличении размера входных данных.
// Big O notation определяет верхнюю границу, или асимптотическую сложность, алгоритма в худшем случае. Таким образом, если время выполнения алгоритма описывается функцией \( f(n) \), то асимптотическая сложность в нотации O-большое будет выглядеть как \( O(g(n)) \), где \( g(n) \) - это функция, определяющая верхнюю границу для \( f(n) \).
// Некоторые распространенные классы сложности в Big O notation:
// 1. \( O(1) \) - постоянное время. Время выполнения алгоритма не зависит от размера входных данных.
// 2. \( O(\log n) \) - логарифмическое время. Время выполнения алгоритма увеличивается логарифмически с ростом размера входных данных.
// 3. \( O(n) \) - линейное время. Время выполнения алгоритма линейно зависит от размера входных данных.
// 4. \( O(n \log n) \) - линейит-логарифмическое время. Время выполнения алгоритма увеличивается пропорционально размеру входных данных, умноженному на логарифм размера входных данных.
// 5. \( O(n^2) \) - квадратичное время. Время выполнения алгоритма увеличивается квадратично с ростом размера входных данных.
// Big O notation позволяет анализировать эффективность алгоритмов и выбирать наиболее подходящий для конкретной задачи, учитывая размер входных данных и требования к производительности.
// -----
// ⋙ ❍ Что выведет console.log(1==‘1’) и console.log(1===‘1’) и почему? ✔
// Выражение `1 == '1'` вернет `true`, а выражение `1 === '1'` вернет `false`.
// При сравнении с использованием оператора `==`, JavaScript выполняет преобразование типов данных (type coercion), чтобы сравнить значения с одинаковым типом. В этом случае строка `'1'` будет преобразована в число, и оба значения станут числовыми. Поскольку числовые значения равны, результат будет `true`.
// Однако, при использовании оператора `===`, сравнение выполняется без преобразования типов данных (strict equality). Значения сравниваются по их типу и значению. Таким образом, число `1` и строка `'1'` не равны по строгому равенству, поскольку они имеют разные типы данных (number и string), даже если их значения по сути одинаковы. Поэтому результат сравнения `1 === '1'` будет `false`.
// -----
// ⋙ ❍ Что такое стрелочная функция и чем она отличается от обычной? ✔
// Стрелочная функция (arrow function) - это новый синтаксис для создания функций в JavaScript, который был добавлен в стандарте ECMAScript 6 (ES6). Он предоставляет более краткий и удобный способ определения функций, особенно для простых случаев.
// Вот пример обычной функции:
// ```javascript
// function add(a, b) {
//   return a + b;
// }
// ```
// А вот пример стрелочной функции:
// ```javascript
// const add = (a, b) => a + b;
// ```
// Основные отличия стрелочных функций от обычных функций:
// 1. Синтаксис: Стрелочные функции имеют более короткий синтаксис по сравнению с обычными функциями. Они используют стрелку `=>` для определения функции.
// 2. Отсутствие собственного контекста (this): У стрелочных функций нет собственного контекста выполнения (this), они используют контекст родительской функции или блока, в котором они были объявлены. В обычных функциях значение `this` зависит от того, как они были вызваны.
// 3. Нельзя использовать как конструкторы: Стрелочные функции нельзя вызывать с использованием оператора `new` и использовать как конструкторы объектов. Они не имеют прототипа и не могут быть вызваны с оператором `new`.
// 4. Отсутствие свойства arguments: У стрелочных функций нет свойства `arguments`, которое доступно в обычных функциях. Вместо этого они могут использовать `...rest`, чтобы получить аргументы.
// 5. Невозможность использования с методами объекта: В стрелочных функциях нельзя использовать `super`, они не имеют `prototype` и не могут быть использованы как методы объекта.
// Стрелочные функции удобны для использования в простых случаях, когда не требуется свой контекст выполнения и нет необходимости использовать `this`, `arguments`, `super` и другие особенности обычных функций. Однако, они не всегда подходят для всех сценариев, особенно когда требуется доступ к контексту выполнения или использование иных особенностей обычных функций.
// -----
// ⋙ ❍ В каком порядке выведется console.log()? ✔
// setTimeout(function timeout() {
//     console.log('Таймаут');
// }, 0);
// let p = new Promise(function(resolve, reject) {
//     console.log('Создание промиса');
//     resolve();
// });
// p.then(function(){
//     console.log('Обработка промиса');
// });
// console.log('Конец скрипта');
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10
// 11
// 12
// 13
// 14
// setTimeout(function timeout() {
//     console.log('Таймаут');
// }, 0);
// let p = new Promise(function(resolve, reject) {
//     console.log('Создание промиса');
//     resolve();
// });
// p.then(function(){
//     console.log('Обработка промиса');
// });
// console.log('Конец скрипта');
// Чтобы определить порядок вывода `console.log()`, нужно учитывать асинхронность выполнения кода. Давайте разберем, в каком порядке будут выполняться операции:
// 1. Сначала выполняются все синхронные операции, то есть:
// - Выводится 'Создание промиса'.
// - Создается и резолвится промис.
// - Выводится 'Конец скрипта'.
// 2. Затем выполняются обработчики промисов и асинхронные операции из очереди микрозадач (microtask queue):
// - Обработчик промиса выводит 'Обработка промиса'.
// 3. В конце выполняются функции обратного вызова таймаутов (setTimeout) и асинхронные операции из очереди задач (task queue):
// - Выводится 'Таймаут'.
// Таким образом, порядок вывода будет следующим:
// ```
// - Создание промиса
// - Конец скрипта
// - Обработка промиса
// - Таймаут
// ```
// -----
// ⋙ ❍ Рассказать про call, apply и bind? ✔
// `call`, `apply` и `bind` - это методы JavaScript, которые позволяют управлять контекстом выполнения функции (значением `this`) и передавать аргументы при вызове функции.
// 1. call: Метод `call` вызывает функцию с указанным значением `this` и аргументами, переданными в виде списка. Синтаксис: `function.call(thisArg, arg1, arg2, ...)`. Здесь `thisArg` - это значение, которое будет использоваться в качестве контекста выполнения функции.
// Пример использования `call`:
// ```javascript
// const person = {
//   fullName: function(city, country) {
//     return this.firstName + ' ' + this.lastName + ', ' + city + ', ' + country;
//   }
// };

// const person1 = {
//   firstName: 'John',
//   lastName: 'Doe'
// };

// console.log(person.fullName.call(person1, 'New York', 'USA')); // Выведет: John Doe, New York, USA
// ```
// 2. apply: Метод `apply` работает аналогично `call`, но принимает аргументы в виде массива. Синтаксис: `function.apply(thisArg, [argsArray])`.
// Пример использования `apply`:
// ```javascript
// const person = {
//   fullName: function(city, country) {
//     return this.firstName + ' ' + this.lastName + ', ' + city + ', ' + country;
//   }
// };

// const person1 = {
//   firstName: 'John',
//   lastName: 'Doe'
// };

// console.log(person.fullName.apply(person1, ['New York', 'USA'])); // Выведет: John Doe, New York, USA
// ```
// 3. bind: Метод `bind` создает новую функцию с указанным значением `this`, которое не может быть изменено в будущем, и аргументами, если они указаны. Этот метод полезен, когда вам нужно сохранить определенное значение `this` для функции, независимо от контекста, в котором она будет вызвана. Синтаксис: `function.bind(thisArg, arg1, arg2, ...)`. Здесь `thisArg` - значение, которое будет использоваться в качестве контекста выполнения функции.
// Пример использования `bind`:
// ```javascript
// const person = {
//   fullName: function(city, country) {
//     return this.firstName + ' ' + this.lastName + ', ' + city + ', ' + country;
//   }
// };

// const person1 = {
//   firstName: 'John',
//   lastName: 'Doe'
// };

// const fullNameFunction = person.fullName.bind(person1);
// console.log(fullNameFunction('New York', 'USA')); // Выведет: John Doe, New York, USA
// ```
// Все эти методы позволяют явно указать значение `this` при вызове функции, что делает их мощными инструментами для управления контекстом выполнения функций в JavaScript.
// -----
// ⋙ ❍ Как можно скопировать объект (вопрос про Object.assign(), перебор в цикле, Spread оператор, JSON.stringify -> JSON.parse)? ✔
// Вы правы, существует несколько способов скопировать объект в JavaScript. Рассмотрим каждый из них:
// 1. Object.assign():
// ```javascript
// const original = { a: 1, b: 2 };
// const copy = Object.assign({}, original);
// ```
// 2. Перебор в цикле:
// ```javascript
// const original = { a: 1, b: 2 };
// const copy = {};
// for (let key in original) {
//   copy[key] = original[key];
// }
// ```
// 3. Spread оператор:
// ```javascript
// const original = { a: 1, b: 2 };
// const copy = { ...original };
// ```
// 4. JSON.stringify() -> JSON.parse():
// ```javascript
// const original = { a: 1, b: 2 };
// const copy = JSON.parse(JSON.stringify(original));
// ```
// Каждый из этих способов имеет свои особенности:
// - `Object.assign()`: Копирует только значения свойств объекта. Если объект содержит вложенные объекты или ссылки на другие объекты, они будут скопированы по ссылке, а не по значению.
// - Перебор в цикле: Простой и понятный способ копирования объекта, но не работает с вложенными объектами и массивами.
// - Spread оператор: Позволяет создать поверхностную копию объекта. Как и `Object.assign()`, не обрабатывает вложенные объекты глубоко.
// - `JSON.stringify() -> JSON.parse()`: Создает глубокую копию объекта, копируя значения свойств и их вложенные объекты или массивы. Однако этот метод не поддерживает копирование функций, объектов с круговыми ссылками или тех объектов, которые содержат специфичные свойства, такие как `Symbol`.
// При выборе способа копирования объекта следует учитывать структуру объекта, необходимость глубокого или поверхностного копирования и возможные нежелательные побочные эффекты, такие как потеря функций или круговые ссылки.
// -----
// ⋙ ❍ Как копируется объект (по ссылке или по значению)? ✔
// В JavaScript объекты копируются по ссылке, а не по значению, за исключением некоторых специальных случаев или методов, которые создают глубокие копии. Это означает, что при присваивании одного объекта другой переменной создается копия ссылки на объект, а не самого объекта.
// Рассмотрим пример:
// ```javascript
// const original = { a: 1, b: 2 };
// const copy = original;
// copy.a = 3;

// console.log(original.a); // Выведет: 3
// ```
// В этом примере `original` и `copy` указывают на один и тот же объект в памяти. Поэтому при изменении свойств через одну переменную изменения будут видны и через другую.
// Есть несколько способов создания копии объекта:
// 1. Поверхностная копия: Методы такие как `Object.assign()`, Spread оператор `{ ...obj }` или перебор в цикле создают поверхностные копии объектов. Они копируют только свойства объекта, но не их значения. Если объект содержит вложенные объекты, они будут скопированы по ссылке.
// 2. Глубокая копия: Методы такие как `JSON.stringify()` и `JSON.parse()` могут использоваться для создания глубоких копий объектов. Они сериализуют объект в строку JSON, а затем снова парсят эту строку в новый объект. Этот метод создает новые объекты для каждого свойства и их значений, что гарантирует, что копии объектов не будут иметь ссылок на исходные объекты. Однако этот метод не поддерживает копирование функций, объектов с круговыми ссылками или специфичные свойства, такие как `Symbol`.
// Выбор между поверхностной и глубокой копией зависит от ваших потребностей. Если вам нужна простая поверхностная копия, используйте `Object.assign()` или Spread оператор. Если вам нужна полная копия объекта с вложенными структурами, используйте методы сериализации и десериализации JSON или другие библиотеки для глубокого копирования.
// -----
// ⋙ ❍ Что будет если объекту, объявленному через const, изменить значения полей? ✔
// Если объект объявлен с использованием `const`, это означает, что ссылка на этот объект не может быть изменена. Однако содержимое объекта может быть изменено, если оно не является неизменяемым.
// Давайте рассмотрим пример:
// ```javascript
// const person = {
//   name: 'John',
//   age: 30
// };

// person.name = 'Jane'; // Изменяем значение поля name
// person.age = 35;      // Изменяем значение поля age

// console.log(person); // Выведет: { name: 'Jane', age: 35 }
// ```
// В этом примере, хотя `person` объявлен с использованием `const`, мы можем изменить значения его полей. Это происходит потому, что `const` ограничивает изменение ссылки на объект, но не его содержимое.
// Однако, если попытаться присвоить объекту новое значение или перезаписать ссылку на объект, JavaScript выдаст ошибку:
// ```javascript
// const person = {
//   name: 'John',
//   age: 30
// };

// person = {}; // Ошибка: "Assignment to constant variable."
// ```
// Поэтому, если вам нужно полностью предотвратить изменение объекта, вам следует использовать методы для глубокого замораживания объекта, такие как `Object.freeze()`, которые защищают от изменений как ссылку на объект, так и его содержимое.
// -----
// ⋙ ❍ Как можно сделать объект иммутабельным? Вопрос об Object.freeze? ✔
// Для создания иммутабельного объекта в JavaScript вы можете использовать метод `Object.freeze()`. Этот метод "замораживает" объект, делая его неизменяемым: нельзя добавлять новые свойства, изменять существующие или удалять их.
// Вот как вы можете использовать `Object.freeze()` для создания иммутабельного объекта:
// ```javascript
// const obj = {
//   property1: 'value1',
//   property2: 'value2'
// };

// // Замораживаем объект
// Object.freeze(obj);

// // Попытка изменить свойство объекта
// obj.property1 = 'new value'; // Не будет совершено никаких изменений
// ```
// Вы также можете использовать `Object.freeze()` в сочетании с рекурсивным проходом по объекту для замораживания всех вложенных объектов и создания глубокой иммутабельности:
// ```javascript
// function deepFreeze(obj) {
//   // Получаем имена всех свойств объекта
//   const propNames = Object.getOwnPropertyNames(obj);

//   // Замораживаем все свойства объекта
//   propNames.forEach(function(name) {
//     const prop = obj[name];

//     // Если свойство является объектом и не было заморожено ранее, замораживаем его
//     if (typeof prop === 'object' && prop !== null && !Object.isFrozen(prop)) {
//       deepFreeze(prop);
//     }
//   });

//   // Замораживаем сам объект
//   return Object.freeze(obj);
// }

// const obj = {
//   nested: {
//     property1: 'value1',
//     property2: 'value2'
//   }
// };

// deepFreeze(obj);

// // Попытка изменить вложенное свойство объекта
// obj.nested.property1 = 'new value'; // Не будет совершено никаких изменений
// ```
// Таким образом, использование `Object.freeze()` позволяет создать объект, который не может быть изменен, что обеспечивает безопасность данных и предотвращает неожиданные изменения в приложении.
// -----
// ⋙ ❍ В чем отличие примитивов от объекта? ✔
// Ответ: примитивы копируются по значению, объект по ссылке;
// Верно, примитивы и объекты в JavaScript отличаются в том, как они обрабатываются в памяти:
// 1. Примитивы (primitive types): Включают в себя типы данных, такие как числа, строки, логические значения (true/false), null и undefined. Примитивные значения копируются по значению, что означает, что когда вы присваиваете примитивное значение переменной или передаете его в функцию, создается копия этого значения.
// Пример:
// ```javascript
// var a = 5;
// var b = a;
// b = 10;
// console.log(a); // Вывод: 5
// console.log(b); // Вывод: 10
// ```
// 2. Объекты (objects): Представляют собой совокупности свойств и методов. Объекты копируются по ссылке, что означает, что при присваивании объекта переменной или передаче его в функцию передается ссылка на объект, а не сам объект. Поэтому изменения, внесенные в объект через одну переменную, отразятся на других переменных, указывающих на тот же объект.
// Пример:
// ```javascript
// var obj1 = { name: 'John' };
// var obj2 = obj1;
// obj2.name = 'Jane';
// console.log(obj1.name); // Вывод: Jane
// console.log(obj2.name); // Вывод: Jane
// ```
// Таким образом, примитивы копируются по значению, а объекты - по ссылке. Это важное различие, которое нужно учитывать при работе с данными в JavaScript.
// -----
// ⋙ ❍ Прототипное наследование? ✔
// Это особенность языка JavaScript, которая позволяет объектам наследовать свойства и методы других объектов через свойство `prototype`. В отличие от классического наследования, применяемого в языках программирования, таких как Java или C++, где классы явно наследуются друг от друга, в JavaScript объекты наследуются от других объектов.
// Каждый объект в JavaScript имеет ссылку на свой прототип (prototype), из которого он наследует свойства и методы. Если свойство или метод не найдены в самом объекте, JavaScript ищет их в цепочке прототипов.
// Пр.н. в JavaScript делает код более гибким и динамичным, позволяя создавать объекты на основе других объектов и динамически добавлять или изменять их свойства и методы.
// Пример прототипного наследования в JavaScript:
// ```javascript
// // Определение прототипа
// var animal = {
//   type: 'Animal',
//   sound: function() {
//     console.log('The ' + this.type + ' makes a sound');
//   }
// };

// // Создание объекта на основе прототипа
// var dog = Object.create(animal);
// dog.type = 'Dog';

// // Вызов метода наследуемого объекта
// dog.sound(); // Вывод: The Dog makes a sound
// ```
// В этом примере объект `dog` наследует свойства и методы от объекта `animal` через прототип.
// /Пр. н. в JavaScript позволяет объектам наследовать свойства и методы других объектов через их прототипы. Вот пример:
// ```javascript
// // Создаем объект-прототип
// let animal = {
//   makeSound: function() {
//     console.log('Животное издает звук');
//   }
// };

// // Создаем объект, который наследует свойства и методы объекта-прототипа
// let dog = Object.create(animal);
// dog.breed = 'Labrador';

// // Можем использовать методы из прототипа
// dog.makeSound(); // Выведет: Животное издает звук

// // Добавляем метод к объекту-прототипу
// animal.walk = function() {
//   console.log('Животное идет');
// };

// // Объект, созданный после изменения прототипа, также получит доступ к новому методу
// dog.walk(); // Выведет: Животное идет
// ```
// В этом примере объект `dog` создан с использованием `Object.create()`, где `animal` является его прототипом. Объект `dog` наследует метод `makeSound` от объекта `animal`. Позднее метод `walk` добавлен к объекту `animal`, и объект `dog` тоже получает доступ к этому методу благодаря прототипному наследованию.
// /П.Н. в JavaScript позволяет объектам наследовать свойства и методы от других объектов. Каждый объект имеет свойство `prototype`, которое указывает на другой объект, называемый прототипом. При обращении к свойству или методу объекта JavaScript сначала ищет их в самом объекте, а затем, если не найдено, в его прототипе. Этот процесс продолжается до тех пор, пока не будет найдено свойство или не будет достигнут конечный прототип `null`. Прототипное наследование позволяет создавать иерархию объектов, делая код более гибким и эффективным. Вот пример:
// ```javascript
// // Создаем родительский объект
// let Animal = {
//     sound: 'Животное издает звук',
//     makeSound: function() {
//         console.log(this.sound);
//     }
// };

// // Создаем объект-наследник, который будет наследовать свойства и методы от родительского объекта
// let Dog = Object.create(Animal);
// Dog.sound = 'Собака лает'; // Переопределяем свойство sound

// // Вызываем метод объекта-наследника
// Dog.makeSound(); // Выведет "Собака лает"
// ```
// В этом примере:
// - У нас есть объект `Animal`, у которого есть свойство `sound` и метод `makeSound`, который выводит значение этого свойства.
// - Мы создаем объект `Dog`, используя метод `Object.create()`, который принимает `Animal` в качестве прототипа. Теперь объект `Dog` наследует все свойства и методы от `Animal`.
// - Мы переопределяем свойство `sound` в объекте `Dog`.
// - При вызове метода `makeSound` у объекта `Dog` будет использоваться свойство `sound`, определенное в объекте `Dog`, а не унаследованное от `Animal`.
// -----
// ⋙ ❍ Что такое виртуальное дерево (как концепция вне контекста React)? ✔
// В контексте вне React, виртуальное дерево (Virtual DOM) - это концепция, которая представляет собой виртуальное представление структуры DOM дерева в памяти компьютера. Вместо того, чтобы напрямую обновлять DOM при каждом изменении данных или состояния, используется виртуальное представление, которое затем сравнивается с реальным DOM для выявления изменений. Такой подход позволяет уменьшить количество манипуляций с реальным DOM, что ведет к повышению производительности при работе с веб-приложениями.
// Обычно виртуальное дерево представляет собой древовидную структуру данных, похожую на реальное DOM дерево, но хранящуюся в памяти компьютера. Виртуальное дерево используется для эффективного вычисления различий между предыдущим и текущим состоянием, а также для оптимизации обновления пользовательского интерфейса.
// -----
// ⋙ ❍ Рассказать о процессе рендеринга HTML-страницы? ✔
// Процесс рендеринга HTML-страницы в браузере включает несколько этапов:
// 1. Получение HTML: Браузер загружает HTML-документ с веб-сервера или из локального кэша.
// 2. Построение DOM (Document Object Model): Браузер разбирает HTML-документ и строит древовидную структуру DOM, представляющую элементы страницы и их взаимосвязи.
// 3. Построение CSSOM (CSS Object Model): Браузер анализирует CSS-стили, связанные с HTML-элементами, и строит древовидную структуру CSSOM, представляющую стили и их наследование.
// 4. Формирование Render Tree (дерево рендеринга): Браузер комбинирует DOM и CSSOM для создания дерева рендеринга, которое содержит только те узлы, которые будут отображены на экране, и их стили.
// 5. Layout (раскладка): Браузер определяет размеры и позиции элементов на странице в соответствии с их стилями и содержимым, используя информацию из дерева рендеринга.
// 6. Paint (отрисовка): Браузер отображает каждый элемент на экране, преобразуя информацию о размерах и позициях из Layout в пиксели на экране.
// 7. Composite (компоновка): Браузер объединяет отрисованные элементы в слои и выполняет компоновку, чтобы сформировать окончательное изображение страницы.
// Этот процесс происходит каждый раз, когда браузер загружает новую HTML-страницу или обновляет текущую. Оптимизация каждого этапа процесса рендеринга помогает повысить производительность и отзывчивость веб-приложений.
// -----
// ⋙ ❍ Какие этапы из рендеринга будут задействованы при перерисовке (вопрос про Reflow)? ✔
// При перерисовке веб-страницы, включая изменение стилей или размеров элементов, задействованы следующие этапы из рендеринга:
// 1. Recalculation (пересчет стилей): Браузер пересчитывает стили всех элементов, затронутых изменением. Это включает в себя определение новых значений для CSS свойств, учитывая их наследование и каскадирование.
// 2. Reflow (перерасчет): После пересчета стилей браузер производит перерасчет геометрии всех элементов, определяя их размеры и позиции в соответствии с новыми стилями. Это может привести к изменению положения и размеров других элементов на странице.
// 3. Repaint (перерисовка): После перерасчета браузер перерисовывает элементы с учетом их новых размеров и положения. Это включает в себя обновление пикселей на экране в соответствии с новыми стилями.
// Каждый из этих этапов является ресурсоемким процессом, поэтому важно минимизировать количество перерасчетов и перерисовок на странице для повышения производительности веб-приложения.
// -----
// ⋙ ❍ Что такое requestAnimationFrame? ✔
// `requestAnimationFrame` - это метод в браузерном JavaScript, который используется для выполнения анимаций и обновления графики в более эффективный и синхронный способ, чем использование метода `setTimeout` или `setInterval`/синхронно с обновлением экрана, обеспечивая плавные и эффективные анимации в веб-приложениях.
// Основные особенности `requestAnimationFrame`:
// 1. Синхронизация с обновлением экрана: Метод `requestAnimationFrame` синхронизирован с обновлением кадров на экране, что обеспечивает более плавные и качественные анимации, особенно на устройствах с высокой частотой обновления экрана.
// 2. Оптимизация производительности: Браузер автоматически оптимизирует выполнение анимаций, приостанавливая их при переходе на другую вкладку или минимизации окна браузера, что помогает снизить нагрузку на процессор и увеличить время жизни батареи на мобильных устройствах.
// 3. Автоматическая регулировка кадров в секунду: Браузер автоматически регулирует скорость обновления кадров в зависимости от возможностей устройства и текущей нагрузки на процессор, что помогает предотвратить перегрузку и улучшить производительность.
// Пример использования `requestAnimationFrame`:
// ```javascript
// function animate() {
//   // выполнять анимацию
//   requestAnimationFrame(animate);
// }

// // начать выполнение анимации
// animate();
// ```
// В этом примере `animate()` будет вызываться перед каждым обновлением кадра на экране, обеспечивая плавную и эффективную анимацию.
// -----
// ⋙ ❍ Что такое Event Loop? ✔
// Event Loop (цикл событий) - это механизм в JavaScript, который позволяет выполнение асинхронного кода и обработку событий. В основе его работы лежит однопоточная модель выполнения, где выполнение кода происходит последовательно, поэтому асинхронные операции не блокируют основной поток исполнения.
// Он позволяет JavaScript выполнять асинхронные операции, не блокируя основной поток выполнения, что обеспечивает отзывчивость пользовательского интерфейса в веб-приложениях. Event Loop следит за выполнением стека вызовов и очереди обратных вызовов (callbacks), перемещая функции из очереди в стек для выполнения по мере освобождения стека.
// Основные концепции Event Loop:
// 1. Call Stack (стек вызовов): Это механизм, который отслеживает текущее место выполнения в коде JavaScript. Когда функция вызывается, она добавляется в вершину стека, а когда функция завершает выполнение, она удаляется из стека.
// 2. Callback Queue (очередь обратных вызовов): В этой очереди хранятся функции обратного вызова (callbacks), которые должны быть выполнены после завершения выполнения текущего кода и освобождения стека вызовов.
// 3. Event Loop (цикл событий): Это бесконечный цикл, который постоянно проверяет стек вызовов и очередь обратных вызовов. Если стек вызовов пуст и в очереди обратных вызовов есть функции, Event Loop переносит их из очереди в стек вызовов для выполнения.
// Event Loop позволяет JavaScript выполнять асинхронные операции, такие как запросы к серверу, обработка пользовательского ввода и таймеры, без блокировки основного потока выполнения. Это делает JavaScript подходящим для создания интерактивных веб-приложений и обеспечивает отзывчивый пользовательский интерфейс.
// -----
// ⋙ ❍ Что находится “под капотом” GraphQl? ✔
// "Под капотом" GraphQL находится несколько ключевых компонентов и процессов:
// 1. Query Language: GraphQL использует свой собственный язык запросов для описания данных, которые клиент хочет получить от сервера. Этот язык предоставляет клиентам гибкость в выборе необходимых данных и связей между ними.
// 2. Schema Definition Language (SDL): Схема GraphQL определяет типы данных, которые могут быть запрошены и возвращены через GraphQL API. Она описывает доступные запросы (Queries) и мутации (Mutations), а также типы данных и их связи.
// 3. Execution Engine: Когда клиент отправляет запрос GraphQL на сервер, GraphQL Execution Engine обрабатывает этот запрос. Он анализирует запрос, сопоставляет его с определенной схемой и выполняет необходимые операции для
// -----
// ⋙ ❍ Разница между a++ и ++a? ✔
// Разница между операторами `a++` и `++a` заключается в том, когда происходит увеличение значения переменной `a` на единицу.
// 1. a++ (постфиксная форма инкремента):
// - Сначала используется текущее значение переменной `a`, а затем увеличивается на единицу.
// - Постфиксная форма инкремента возвращает старое значение переменной `a`, а затем увеличивает его на единицу.
// Пример:
// ```javascript
// let a = 5;
// let b = a++; // b = 5, a = 6
// ```
// 2. ++a (префиксная форма инкремента):
// - Сначала значение переменной `a` увеличивается на единицу, а затем используется в выражении.
// - Префиксная форма инкремента возвращает новое значение переменной `a` после увеличения.
// Пример:
// ```javascript
// let a = 5;
// let b = ++a; // a = 6, b = 6
// ```
// Таким образом, основное различие между `a++` и `++a` состоит в порядке выполнения операций увеличения значения переменной `a` и возвращения значения.
// / `a++` увеличивает значение `a` после его использования в выражении, в то время как `++a` увеличивает значение `a` перед его использованием.
// -----
// ⋙ ❍ Что такое чистая функция? ✔
// Чистая функция в программировании - это функция, которая:
// Чистая функция - это функция, которая возвращает значение только на основе своих аргументов и не имеет побочных эффектов, таких как изменение внешних переменных или вывод на экран.
// 1. Возвращает значение, основываясь только на своих аргументах: Значение результата функции зависит только от переданных ей аргументов, и она не зависит от состояния программы вне своего контекста. Это означает, что при одинаковых входных данных функция всегда будет возвращать одинаковый результат.
// 2. Не вызывает побочных эффектов: Под побочным эффектом понимается любое изменение состояния программы, которое выходит за пределы области видимости функции, такое как изменение глобальных переменных, изменение состояния объектов, вывод на экран, и так далее.
// Чистые функции имеют следующие преимущества:
// - Предсказуемость: Поскольку чистые функции всегда возвращают одинаковый результат для одних и тех же аргументов, они более предсказуемы и проще для отладки.
// - Тестируемость: Поскольку чистые функции не зависят от внешних факторов, их легко тестировать. Вы можете подставить различные входные данные и проверить, что функция возвращает ожидаемый результат.
// - Масштабируемость: Использование чистых функций облегчает масштабирование вашего кода, поскольку они уменьшают количество взаимосвязей между компонентами программы.
// -----
// ⋙ ❍ Перечислить, что является false в JS (Вопрос о 0, null, false и т.д.)? ✔
// В JavaScript следующие значения считаются ложными (false):
// 1. false: Логическое ложное значение `false`.
// 2. 0: Число ноль (integer).
// 3. NaN: Not-a-Number (не число).
// 4. '': Пустая строка (пустая строка имеет нулевую длину и не содержит ни одного символа).
// 5. null: Специальное значение, которое представляет отсутствие значения.
// 6. undefined: Специальное значение, которое означает, что переменная не имеет значения.
// 7. document.all: Устаревшее свойство, которое возвращает псевдомассив HTML-элементов. В современных браузерах возвращает `false`, но в старых версиях Internet Explorer может возвращать `true`.
// Все остальные значения считаются истинными (true), даже пустой массив `[]` или пустой объект `{}`.
// -----
// ⋙ ❍ Что выведет консоль? Аргументируйте свой ответ. ✔
// (function() {
//     f();
//     f = function() {
//         console.log(1);
//     }
// })()
// function f() {
//     console.log(2)
// }
// f();
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10
// 11
// 12
// 13
// (function() {
//     f();

//     f = function() {
//         console.log(1);
//     }
// })()

// function f() {
//     console.log(2)
// }

// f();
// Этот код вызовет ошибку "TypeError: f is not a function".
// При первом вызове `f();` функция `f` еще не определена, так как вызов `f();` происходит перед присваиванием новой функции `f = function() { console.log(1); }`.
// В результате, будет выброшено исключение TypeError, потому что при попытке вызвать `f()` до определения функции, `f` будет равно `undefined`, а не функции.
// -----
// ⋙ ❍ Что выведет консоль? Аргументируйте свой ответ. ✔
// const obj = {
//   name: 'John',
//   getName() {
//     return this.name;
//   }
// };
// const name1 = obj.getName();
// const getName = obj.getName;
// const name2 = getName();
// console.log(`${name1} ${name2}`); // ?
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10
// 11
// const obj = {
//   name: 'John',
//   getName() {
//     return this.name;
//   }
// };
// const name1 = obj.getName();
// const getName = obj.getName;
// const name2 = getName();
// console.log(`${name1} ${name2}`); // ?
// В консоль будет выведено:
// ```
// John undefined
// ```
// Это происходит из-за того, что контекст выполнения функции `getName` изменяется при вызове отдельно от объекта `obj`.
// 1. Переменная `name1` получает значение `John`, потому что функция `getName` вызывается в контексте объекта `obj`, и `this.name` возвращает свойство `name` этого объекта.
// 2. Переменная `getName` присваивается ссылка на функцию `getName` объекта `obj`, но без привязки к контексту. Поэтому, когда функция `getName` вызывается в контексте глобального объекта (или `undefined` в строгом режиме), `this.name` возвращает `undefined`.
// Поэтому, при использовании интерполяции строк `${name1} ${name2}`, первая переменная `name1` будет иметь значение `'John'`, а вторая переменная `name2` будет иметь значение `undefined`.
// -----
// ⋙ ❍ Создайте метод у объекта String, который многократно повторяет строку (не используя метод .repeat()). ✔
// console.log("hello". customRepeat(3)); // “hellohellohello”
// 1
// console.log("hello". customRepeat(3)); // “hellohellohello”
// Вы можете создать метод `customRepeat` для объекта `String`, который будет многократно повторять строку. Вот пример, как это можно сделать:
// ```javascript
// String.prototype.customRepeat = function(count) {
//   let repeatedString = '';
//   for (let i = 0; i < count; i++) {
//     repeatedString += this;
//   }
//   return repeatedString;
// };
// console.log("hello".customRepeat(3)); // Выведет: "hellohellohello"
// ```
// В этом примере мы расширяем прототип `String`, добавляя метод `customRepeat`, который принимает количество повторений и возвращает новую строку, содержащую исходную строку, повторенную заданное количество раз.
// -----
// ⋙ ❍ Есть список элементов button, на которые навешен обработчик события ‘click’. Что попадет в консоль, если пользователь нажмет первую и последнюю кнопку в списке? Аргументируйте свой ответ.
// var nodes = document.getElementsByTagName('button');
// for (var i = 0; i < nodes.length; i++) {
//        nodes[i].addEventListener('click', function() {
//       	console.log('You clicked element #' + i);
//        });
// }
// 1
// 2
// 3
// 4
// 5
// 6
// var nodes = document.getElementsByTagName('button');
// for (var i = 0; i < nodes.length; i++) {
//        nodes[i].addEventListener('click', function() {
//       	console.log('You clicked element #' + i);
//        });
// }
// • При нажатии на первую и последнюю кнопку в списке будут выведены следующие строки в консоль:
// ```
// You clicked element #6
// You clicked element #6
// ```
// Это происходит из-за того, что переменная `i` используется внутри функции обратного вызова для обработчика события 'click'. В JavaScript область видимости переменных объявленных через ключевое слово `var` - это вся функция. В результате, значение переменной `i` будет равно последнему значению, которое она принимает в цикле, то есть `6`. Когда функция обработчика события вызывается при нажатии на кнопку, она видит последнее значение `i`, которое было установлено, то есть `6`, и выводит его в консоль для обоих кнопок.
// -----
// ⋙ ❍ Что выведет в консоль следующий код? Аргументируйте свой ответ. ✔
// function printme() {
//    console.log(1);
//    setTimeout(function() { console.log(2); }, 1000);
//    setTimeout(function() { console.log(3); }, 0);
//    console.log(4);
// }
// printme();
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// function printme() {
//    console.log(1);
//    setTimeout(function() { console.log(2); }, 1000);
//    setTimeout(function() { console.log(3); }, 0);
//    console.log(4);
// }
// printme();
// В консоль будет выведено следующее:
// ```
// 1
// 4
// 3
// 2
// ```
// При вызове функции `printme`, сначала будет выведено `1`, затем `4`, потому что они находятся в синхронном коде функции. Затем будет добавлено два таймера с задержками: один на 1000 миллисекунд (1 секунду) и один на 0 миллисекунд (почти мгновенно). Далее, когда таймер с задержкой в 0 миллисекунд сработает, будет выведено `3`. И, наконец, после истечения 1 секунды, выведется `2`.
// Это происходит из-за того, что даже если задержка таймера равна 0, функция обратного вызова все равно помещается в очередь событий и выполнится после завершения текущего кода. Таким образом, порядок выполнения будет сохранен.
// -----
// ⋙ ❍ Напишите функцию isPalindrome(str), которая проверяет, является ли строка палиндромом ✔
// console.log(isPalindrome('asdsa')) // true
// 1
// console.log(isPalindrome('asdsa')) // true
// Вы можете создать функцию `isPalindrome`, которая будет принимать строку и проверять, является ли она палиндромом. Палиндром - это строка, которая читается одинаково как с начала, так и с конца. Вот как это можно сделать:
// ```javascript
// function isPalindrome(str) {
//   // Удаляем все пробелы из строки и приводим ее к нижнему регистру
//   const formattedStr = str.replace(/\s/g, '').toLowerCase();

//   // Проверяем, является ли строка палиндромом
//   for (let i = 0; i < formattedStr.length / 2; i++) {
//     if (formattedStr[i] !== formattedStr[formattedStr.length - 1 - i]) {
//       return false;
//     }
//   }
//   return true;
// }
// console.log(isPalindrome('asdsa')); // Выведет: true
// ```
// Эта функция сначала форматирует строку, удаляя все пробелы и приводя к нижнему регистру. Затем она сравнивает символы с обоих концов строки, чтобы определить, является ли она палиндромом. Если строка является палиндромом, функция возвращает `true`, в противном случае - `false`.
// -----
// ⋙ ❍ Напишите функцию, складывающую 2 числа, которую можно вызывать следующим образом: ✔
// console.log(sum(2,3));   // 5
// console.log(sum(2)(3));  // 5
// 1
// 2
// console.log(sum(2,3));   // 5
// console.log(sum(2)(3));  // 5
// Вы можете создать функцию `sum`, которая будет принимать один или два аргумента и возвращать сумму этих чисел. Вот как это можно сделать:
// ```javascript
// function sum(a, b) {
//   if (arguments.length === 1) {
//     return function(b) {
//       return a + b;
//     };
//   }
//   return a + b;
// }
// console.log(sum(2, 3));   // Выведет: 5
// console.log(sum(2)(3));   // Выведет: 5
// ```
// Эта функция проверяет, сколько аргументов ей передано. Если передан только один аргумент, она возвращает функцию, которая ожидает второй аргумент и возвращает их сумму. Если передано два аргумента, она просто возвращает их сумму.
// -----
// ⋙ ❍ Поменяйте местами значения целочисленных переменных, не используя временные переменные. Первый вариант – используя ES6, и второй вариант – используя ES5. ✔
// var a = 1;
// var b = 2;

// // b = 1;
// // a = 2;
// 1
// 2
// 3
// 4
// 5
// var a = 1;
// var b = 2;

// // b = 1;
// // a = 2;
// Используя ES6:
// ```javascript
// let a = 1;
// let b = 2;

// [a, b] = [b, a];
// console.log(a, b); // Выведет: 2 1
// ```
// Используя ES5:
// ```javascript
// var a = 1;
// var b = 2;

// a = a + b;
// b = a - b;
// a = a - b;
// console.log(a, b); // Выведет: 2 1
// ```
// -----
// ⋙ ❍ Напишите функцию, проверяющую число на четность, используя только битовые операции ✔
// Так же интервьюеры интересовались следующими темами:
// Конечно, вот функция, которая проверяет число на четность, используя только битовые операции:
// ```javascript
// function isEven(number) {
//   // Проверяем младший бит числа
//   // Если младший бит равен 0, число четное, иначе нечетное
//   return (number & 1) === 0;
// }

// // Пример использования функции
// console.log(isEven(4)); // Выведет true, потому что 4 - четное число
// console.log(isEven(7)); // Выведет false, потому что 7 - нечетное число
// ```
// Эта функция использует побитовое И (`&`) с числом 1, чтобы проверить младший бит числа. Если младший бит равен 0, это означает, что число четное, иначе это нечетное число.
// -----
// ⋙ ❍ Иммутабельность в контексте React + Redux ✔
// Иммутабельность - это концепция, согласно которой данные не могут быть изменены напрямую после их создания. В контексте React и Redux, где данные часто представлены в виде состояний приложения, использование иммутабельности имеет несколько преимуществ:
// Иммутабельность в React + Redux означает создание новых объектов состояния или данных при их изменении, вместо модификации существующих объектов. Это обеспечивает предсказуемость, улучшает производительность и упрощает управление состоянием приложения.
// 1. Предсказуемость: Изменение данных напрямую может привести к неожиданным побочным эффектам и сложным багам. Используя иммутабельность, вы можете быть уверены, что данные не будут меняться непреднамеренно, что делает поведение вашего приложения более предсказуемым.
// 2. Производительность: Изменение данных напрямую может привести к необходимости повторного рендеринга компонентов, даже если данные не изменились в их контексте. Используя иммутабельность, вы можете создавать новые объекты данных при каждом изменении, что помогает React и Redux определить, какие компоненты должны быть перерендерены.
// 3. Отменяемость (Undo/Redo): Иммутабельность делает реализацию механизмов отмены и повтора действий (Undo/Redo) более простой, поскольку каждое действие создает новое состояние, которое можно легко восстановить или откатить.
// 4. Тестирование: Изменение данных напрямую может усложнить тестирование вашего кода. Используя иммутабельность, вы можете создавать предсказуемые результаты, которые легко проверить в ваших тестах.
// В контексте React и Redux, использование иммутабельности означает создание новых объектов состояния или данных при их изменении, вместо модификации существующих объектов. Это может быть достигнуто с помощью методов, таких как `Object.assign()`, spread оператора (`...`), или библиотек для работы с неизменяемыми данными, таких как Immutable.js.
// -----
// ⋙ ❍ Дан не сложный компонент на реакте и необходимо провести ревью (заюзать хуки useMemo / useCallback, вынести повторяющийся код в функцию или переменную и что-то там еще было) ✔
// Давайте посмотрим на ваш компонент и проведем ревью, оптимизируя его с помощью хуков `useMemo` и `useCallback`, а также вынося повторяющийся код в функции или переменные:
// ```javascript
// import React, { useState, useEffect } from 'react';

// const MyComponent = () => {
//   const [count, setCount] = useState(0);
//   const [doubleCount, setDoubleCount] = useState(0);

//   useEffect(() => {
//     const double = count * 2;
//     setDoubleCount(double);
//   }, [count]);

//   const handleIncrement = () => {
//     setCount(count + 1);
//   };

//   const handleDecrement = () => {
//     setCount(count - 1);
//   };

//   return (
//     <div>
//       <p>Count: {count}</p>
//       <p>Double Count: {doubleCount}</p>
//       <button onClick={handleIncrement}>Increment</button>
//       <button onClick={handleDecrement}>Decrement</button>
//     </div>
//   );
// };

// export default MyComponent;
// ```
// Давайте оптимизируем этот компонент:
// 1. Хранение удвоенного значения с помощью `useMemo`:
//  ```javascript
//  const doubleCount = useMemo(() => count * 2, [count]);
//  ```
// 2. Оптимизация обработчиков событий с помощью `useCallback`:
//  ```javascript
//  const handleIncrement = useCallback(() => {
//    setCount((prevCount) => prevCount + 1);
//  }, []);

//  const handleDecrement = useCallback(() => {
//    setCount((prevCount) => prevCount - 1);
//  }, []);
//  ```
// 3. Вынос повторяющегося кода в функцию или переменную:
//  ```javascript
//  const increment = () => {
//    setCount((prevCount) => prevCount + 1);
//  };

//  const decrement = () => {
//    setCount((prevCount) => prevCount - 1);
//  };
//  ```
// Вот полный код с примененными оптимизациями:
// ```javascript
// import React, { useState, useEffect, useMemo, useCallback } from 'react';

// const MyComponent = () => {
//   const [count, setCount] = useState(0);

//   const doubleCount = useMemo(() => count * 2, [count]);

//   const handleIncrement = useCallback(() => {
//     setCount((prevCount) => prevCount + 1);
//   }, []);

//   const handleDecrement = useCallback(() => {
//     setCount((prevCount) => prevCount - 1);
//   }, []);

//   return (
//     <div>
//       <p>Count: {count}</p>
//       <p>Double Count: {doubleCount}</p>
//       <button onClick={handleIncrement}>Increment</button>
//       <button onClick={handleDecrement}>Decrement</button>
//     </div>
//   );
// };

// export default MyComponent;
// ```
// Теперь компонент оптимизирован с использованием хуков `useMemo` и `useCallback`, а также вынесен повторяющийся код в функции или переменные.
// /Давайте проведем ревью компонента, оптимизируя его с помощью хуков `useMemo` и `useCallback`, а также вынося повторяющийся код в функции или переменные:
// ```javascript
// import React, { useState, useEffect } from 'react';

// const MyComponent = () => {
//   const [count, setCount] = useState(0);
//   const [doubleCount, setDoubleCount] = useState(0);

//   useEffect(() => {
//     const double = count * 2;
//     setDoubleCount(double);
//   }, [count]);

//   const handleIncrement = () => {
//     setCount(count + 1);
//   };

//   const handleDecrement = () => {
//     setCount(count - 1);
//   };

//   return (
//     <div>
//       <p>Count: {count}</p>
//       <p>Double Count: {doubleCount}</p>
//       <button onClick={handleIncrement}>Increment</button>
//       <button onClick={handleDecrement}>Decrement</button>
//     </div>
//   );
// };

// export default MyComponent;
// ```
// Оптимизированный код:
// ```javascript
// import React, { useState, useEffect, useMemo, useCallback } from 'react';

// const MyComponent = () => {
//   const [count, setCount] = useState(0);

//   const doubleCount = useMemo(() => count * 2, [count]);

//   useEffect(() => {
//     const double = count * 2;
//     setDoubleCount(double);
//   }, [count]);

//   const handleIncrement = useCallback(() => {
//     setCount(prevCount => prevCount + 1);
//   }, []);

//   const handleDecrement = useCallback(() => {
//     setCount(prevCount => prevCount - 1);
//   }, []);

//   return (
//     <div>
//       <p>Count: {count}</p>
//       <p>Double Count: {doubleCount}</p>
//       <button onClick={handleIncrement}>Increment</button>
//       <button onClick={handleDecrement}>Decrement</button>
//     </div>
//   );
// };

// export default MyComponent;
// ```
// Теперь компонент оптимизирован с использованием хуков `useMemo` и `useCallback`, а также вынесен повторяющийся код в функции или переменные.
// -----
// ⋙ ❍ Причины ререндера компонентов и как их избежать (те же useMemo, React.Memo, разбиение на более мелкие компоненты и т.д.) ✔
// 1. Изменение состояния: Когда состояние компонента изменяется с помощью `setState` или хуков, компонент перерендеривается. Чтобы избежать ненужных ререндеров, используйте `useMemo` или `React.memo` для мемоизации результатов вычислений или повторного рендеринга компонентов.
// 2. Изменение пропсов: Когда пропсы, передаваемые в компонент, изменяются, компонент перерендеривается. Чтобы избежать ререндера из-за изменений в пропсах, используйте `React.memo` для мемоизации компонента или разбейте его на более мелкие компоненты и передавайте только необходимые пропсы.
// 3. Изменение контекста: Если компонент использует контекст и значение контекста изменяется, компонент перерендеривается. Чтобы избежать ненужных ререндеров, используйте мемоизацию с помощью `useMemo` или `React.memo` для компонентов, зависящих от контекста.
// 4. Изменение родительского компонента: Если родительский компонент перерендеривается, все его дочерние компоненты также перерендериваются. Для избежания этого разбейте компоненты на более мелкие, чтобы изолировать их перерендеринг.
// 5. Изменение локального состояния контейнера: Когда родительский компонент перерендеривается, но новое состояние не влияет на дочерние компоненты, можно использовать `useMemo` или `React.memo` для предотвращения ненужного ререндера.
// Чтобы избежать ненужных ререндеров компонентов, используйте следующие методы:
// - useMemo: Мемоизирует результат выполнения функции и возвращает его при последующих вызовах с теми же зависимостями.
// - React.memo: Оборачивает функциональный компонент и мемоизирует его, предотвращая его ререндеринг, если пропсы не изменились.
// - Разбиение на более мелкие компоненты: Разбивайте компоненты на более мелкие, чтобы избежать их ненужного ререндеринга при изменении только части состояния или пропсов.
// - Оптимизация контекста: Используйте мемоизацию с помощью `useMemo` или `React.memo` для компонентов, зависящих от контекста, чтобы избежать ненужных ререндеров при изменении значения контекста.
// -----
// ⋙ ❍ Event Loop, call stack и где это применяется ✔
// Event Loop (цикл событий) и call stack (стек вызовов) - это ключевые концепции в асинхронном JavaScript, которые определяют, как обрабатываются асинхронные операции в браузере или среде выполнения Node.js.
// 1. Call Stack (стек вызовов):
// - Стек вызовов представляет собой структуру данных, которая отслеживает порядок вызова функций в вашем коде.
// - Когда функция вызывается, она помещается в верхушку стека. Когда функция завершает свое выполнение, она удаляется из стека.
// - Call stack используется для выполнения синхронного кода и хранения информации о текущем месте выполнения.
// 2. Event Loop (цикл событий):
// - Event Loop - это механизм, который позволяет JavaScript быть асинхронным и реагировать на события.
// - Он постоянно проверяет, есть ли задачи в очереди событий (event queue).
// - Если стек вызовов пуст и есть задачи в очереди событий, Event Loop берет первую задачу из очереди и помещает ее в стек вызовов для выполнения.
// - Этот процесс повторяется постоянно, что позволяет JavaScript быть асинхронным и реагировать на события пользователя и другие асинхронные операции.
// Где применяется:
// - Event Loop и call stack используются везде, где JavaScript выполняется: в браузерах, Node.js и других средах выполнения JavaScript.
// - В браузере они используются для обработки событий, асинхронных операций (например, AJAX запросов), таймеров и многого другого.
// - В Node.js они используются для обработки асинхронных операций ввода-вывода (I/O), файловой системы, сетевых запросов и т. д.
// Понимание этих концепций позволяет разработчикам писать более эффективный и надежный код, особенно в асинхронных сценариях.
// -----
// ⋙ ❍ Async / await / Promise ✔
// `Async/await` - синтаксический сахар в JavaScript для работы с асинхронным кодом поверх промисов.
// 1. Promise (Обещание):
// - Это объект, представляющий завершение или неуспех/результат асинхронной операции.
// - Promise имеет три состояния: ожидание (pending), выполнение (fulfilled) и отклонение (rejected).
// - Создается с помощью конструктора `Promise`, принимающего функцию-исполнитель (executor) с двумя аргументами: `resolve` и `reject`.
// 2. Async/await:
// - `async` объявляет асинхронную функцию, которая возвращает промис.
// - `await` используется внутри асинхронной функции для ожидания выполнения другого промиса.
// - Оператор `await` приостанавливает выполнение асинхронной функции до тех пор, пока промис не завершится, и возвращает его результат.
// - Это делает код более читаемым и позволяет избежать глубокой вложенности колбэков.
// Пример использования `async/await`:
// ```javascript
// async function fetchData() {
// try {
//  const response = await fetch('https://api.example.com/data');
//  const data = await response.json();
//  return data;
// } catch (error) {
//  console.error('Error fetching data:', error);
//  throw error;
// }
// }

// fetchData()
// .then(data => console.log('Data:', data))
// .catch(error => console.error('Error:', error));
// ```
// В этом примере функция `fetchData` асинхронно получает данные из API с помощью `fetch`, ожидая завершения операции с помощью `await`, а затем возвращает эти данные или выбрасывает ошибку при возникновении проблем. С помощью методов `then` и `catch` мы обрабатываем результаты выполнения промиса.
// -----
// ⋙ ❍ requestAnimationFrame ✔
// `requestAnimationFrame` - это метод в браузерной среде выполнения JavaScript, который позволяет выполнять анимации и другие задачи, которые требуют обновления экрана, с оптимальной производительностью и синхронизацией с обновлением кадров в браузере.
// /это метод в браузерном JavaScript, который позволяет выполнить функцию перед следующим обновлением экрана, обеспечивая оптимальную производительность и синхронизацию с обновлением кадров. Это используется для анимаций и других задач, требующих обновления экрана.
// Основные особенности `requestAnimationFrame`:
// 1. Оптимальное обновление кадров:
// - `requestAnimationFrame` запрашивает браузер запланировать перерисовку при следующей возможности обновления экрана перед выводом следующего кадра анимации или другого визуального обновления.
// 2. Синхронизация с обновлением экрана:
// - Метод гарантирует, что функция анимации будет вызвана перед обновлением кадра, что позволяет предотвратить мерцание и синхронизировать анимацию с обновлением экрана.
// 3. Автоматическая пауза при скрытии вкладки:
// - Вкладка браузера автоматически приостанавливает выполнение кода в методе `requestAnimationFrame`, если она не активна или скрыта, что помогает сэкономить ресурсы устройства.
// Пример использования `requestAnimationFrame`:
// ```javascript
// function animate() {
//   // Ваш код анимации или других визуальных изменений
//   // Вызов requestAnimationFrame внутри функции анимации позволяет ее циклическое выполнение
//   requestAnimationFrame(animate);
// }

// // Запуск анимации
// animate();
// ```
// В этом примере функция `animate` вызывается снова и снова с помощью `requestAnimationFrame`, обеспечивая циклическое выполнение анимации с оптимальной производительностью и синхронизацией с обновлением кадров в браузере.
// -----
// ⋙ ❍ Задача на рекурсию ✔
// Простая задача на рекурсию: написать функцию для вычисления факториала числа.
// Факториал числа \( n \) (обозначается как \( n! \)) - это произведение всех положительных целых чисел от 1 до \( n \). Например, факториал 5 (обозначается как \( 5! \)) равен \( 5 \times 4 \times 3 \times 2 \times 1 = 120 \).
// Вот решение на JavaScript с использованием рекурсии:
// ```javascript
// function factorial(n) {
//   // Базовый случай: если n равно 0 или 1, вернуть 1
//   if (n === 0 || n === 1) {
//     return 1;
//   }
//   // Рекурсивный случай: вычислить факториал числа n как произведение n и факториала (n - 1)
//   else {
//     return n * factorial(n - 1);
//   }
// }

// // Пример использования функции
// console.log(factorial(5)); // Выведет 120
// ```
// Эта функция рекурсивно вызывает саму себя до достижения базового случая (когда \( n = 0 \) или \( n = 1 \)), а затем возвращает результат.
// ---------------------------------------------------------------------------------------------
// [РЕАЛЬНЫЕ ЗАДАЧИ MIDDLE ИЗ РАЗНЫХ КОМПАНИЙ]:
// ---------------------
// ⋙ ❍ Что выведет консоль? ✔
// console.log(1);
// setTimeout(() => console.log(2), 1000);
// setTimeout(() => console.log(3), 500);
// console.log(4);
// 1
// 2
// 3
// 4
// console.log(1);
// setTimeout(() => console.log(2), 1000);
// setTimeout(() => console.log(3), 500);
// console.log(4);
// Первый вызов `console.log(1);` будет сразу же выведен, затем код продолжит выполнение.
// Далее, второй `console.log(2)` будет выведен через 1000 миллисекунд (1 секунда), так как он установлен с помощью `setTimeout` на 1000 миллисекунд.
// Третий `console.log(3)` будет выведен через 500 миллисекунд, так как он установлен с помощью `setTimeout` на 500 миллисекунд.
// Наконец, `console.log(4);` будет выведен после первого `console.log(2)` и второго `console.log(3)`, потому что он идет сразу после них.
// Таким образом, вывод будет:
// ```
// 1
// 4
// 3
// 2
// ```
// -----
// ⋙ ❍ Что выведет консоль? ✔
// console.log(0.1 + 0.2 == 0.3)
// 1
// console.log(0.1 + 0.2 == 0.3)
// Оба вызова `console.log` вернут `false`.
// Это происходит из-за особенностей представления чисел с плавающей точкой в JavaScript. Внутренне, числа с плавающей точкой представлены в двоичном виде, и иногда точность при вычислениях может теряться из-за ограничений в точности представления.
// В данном случае, когда вы складываете `0.1` и `0.2`, результат не будет идентичен `0.3` из-за потери точности при представлении чисел с плавающей точкой.
// -----
// ⋙ ❍ Классы, наследование, доступ к родительскому классу через super() ✔
// Классы в JavaScript предоставляют синтаксический сахар для создания объектно-ориентированных структур. Они позволяют определить шаблон объекта с его свойствами и методами. Наследование в классах позволяет создавать подклассы, которые наследуют свойства и методы родительского класса. Для доступа к родительскому классу из подкласса используется ключевое слово `super()`.
// /Классы в JavaScript представляют собой шаблоны для создания объектов с определенными свойствами и методами. Наследование позволяет подклассам наследовать функциональность родительских классов. Для доступа к методам и конструктору родительского класса в подклассе используется ключевое слово `super()`.
// Вот краткое описание каждого из этих концептов:
// 1. Классы: Классы в JavaScript определяются с помощью ключевого слова `class` и могут содержать конструкторы, свойства и методы.
// ```javascript
// class Animal {
//   constructor(name) {
//     this.name = name;
//   }

//   speak() {
//     console.log(this.name + ' makes a noise.');
//   }
// }
// ```
// 2. Наследование: Для создания подкласса, который наследует свойства и методы родительского класса, используется ключевое слово `extends`.
// ```javascript
// class Dog extends Animal {
//   constructor(name, breed) {
//     super(name); // вызов конструктора родительского класса
//     this.breed = breed;
//   }

//   speak() {
//     console.log(this.name + ' barks.');
//   }
// }
// ```
// 3. Доступ к родительскому классу через super(): В конструкторе подкласса ключевое слово `super()` используется для вызова конструктора родительского класса и передачи ему параметров.
// ```javascript
// class Dog extends Animal {
//   constructor(name, breed) {
//     super(name); // вызов конструктора родительского класса
//     this.breed = breed;
//   }

//   speak() {
//     super.speak(); // вызов метода родительского класса
//     console.log(this.name + ' barks.');
//   }
// }
// ```
// Эти концепции позволяют создавать иерархии классов, где подклассы могут наследовать функциональность родительских классов, а также расширять или переопределять ее по необходимости.
// -----
// ⋙ ❍ Что такое new? ✔
// `new` в JavaScript используется для создания нового экземпляра объекта с помощью функции-конструктора. Когда вы используете оператор `new` перед вызовом функции, происходит следующее:
// 1. Создается новый пустой объект.
// 2. Ключевое слово `this` внутри функции ссылается на этот новый объект.
// 3. Функция выполняется.
// 4. Если функция явно не возвращает объект, то `this` (т.е. созданный объект) возвращается из функции.
// Вот пример:
// ```javascript
// function Person(name, age) {
//   this.name = name;
//   this.age = age;
// }

// const john = new Person('John', 30);
// console.log(john.name); // "John"
// console.log(john.age); // 30
// ``
// Здесь `new Person('John', 30)` создает новый объект `john`, который содержит свойства `name` и `age`, установленные в значения `'John'` и `30` соответственно.
// -----
// ⋙ ❍ Рассказать про контекст this ✔
// Контекст `this` в JavaScript определяет, какая именно объектная ссылка используется в текущем контексте выполнения кода. Значение `this` зависит от того, как именно вызывается функция. Вот основные сценарии, в которых используется `this`:
// /Контекст `this` в JavaScript определяет, на что ссылается внутри функции. Он может указывать на глобальный объект, объект, в котором вызван метод, новый созданный объект (при использовании конструктора), или быть не определенным. В ES6 стрелочные функции заимствуют `this` из окружающего контекста.
// 1. Глобальный контекст: В глобальном контексте, значение `this` ссылается на глобальный объект, такой как `window` в браузере или `global` в Node.js.
// ```javascript
// console.log(this === window); // true (если код выполняется в браузере)
// ```
// 2. Метод объекта: Когда функция вызывается как метод объекта, значение `this` ссылается на сам объект, на котором вызван метод.
// ```javascript
// const obj = {
//   name: "John",
//   greet() {
//     console.log("Hello, " + this.name);
//   }
// };

// obj.greet(); // "Hello, John"
// ```
// 3. Конструктор: Когда функция используется как конструктор с оператором `new`, значение `this` ссылается на новый экземпляр объекта, который создается функцией-конструктором.
// ```javascript
// function Person(name) {
//   this.name = name;
// }

// const john = new Person("John");
// console.log(john.name); // "John"
// ```
// 4. Вызов без контекста (неявный контекст): Если функция вызывается без явного указания контекста (через точку), то в строгом режиме `this` будет `undefined`, в нестрогом режиме - на глобальный объект.
// ```javascript
// function sayName() {
//   console.log(this.name);
// }

// const obj = {
//   name: "John",
//   sayName: sayName
// };

// obj.sayName(); // "John"

// const func = obj.sayName;
// func(); // undefined (в строгом режиме), "John" (в нестрогом режиме)
// ```
// 5. Контекст вызова функции: В ES6, стрелочные функции не имеют собственного значения `this` и заимствуют его из контекста, в котором они были определены. Это означает, что `this` внутри стрелочной функции будет таким же, как внутри внешней функции.
// ```javascript
// const obj = {
//   name: "John",
//   greet: function() {
//     const innerFunc = () => {
//       console.log("Hello, " + this.name);
//     };
//     innerFunc();
//   }
// };

// obj.greet(); // "Hello, John"
// ```
// Важно помнить, что контекст `this` в JavaScript динамически определяется во время выполнения, поэтому его значение может изменяться в зависимости от того, как именно вызывается функция.
// -----
// ⋙ ❍ Что выведет консоль? ✔
// console.log(1 + '2');
// 1
// console.log(1 + '2');
// Обе команды `console.log` выведут строку `"12"`.
// В JavaScript, если один из операндов оператора `+` является строкой, то другой операнд будет автоматически преобразован в строку и выполнится конкатенация строк. Таким образом, выражение `1 + '2'` приводится к конкатенации числа `1` со строкой `'2'`, что дает строку `'12'`.
// -----
// ⋙ ❍ Что вернет функция? ✔
// function f() {
//   let array = [];
//   let index = 0;
//   while(index < 5) {
//     function item() {
//       console.log(index);
//     }

//     array.push(item);
//     ++index;
//   }

//   return array;
// };

// let f2 = f();
// f2[0]();

// function f() {
//   let array = [];
//   let index = 0;
//   while(index < 5) {
//     function item() {
//       console.log(index);
//     }

//     array.push(item);
//     ++index;
//   }

//   return array;
// };

// let f2 = f();
// f2[0]();
// Функция вернет массив функций, каждая из которых будет выводить значение переменной `index` в момент вызова. Однако, из-за особенностей JavaScript и замыканий, все функции в массиве будут иметь доступ к одной и той же переменной `index`, а не к ее значению в момент создания функции.
// Поэтому при вызове `f2[0]();` будет выведено значение переменной `index`, которое будет равно последнему значению, которое приняла переменная `index` в цикле while, в данном случае `5`.
// Таким образом, при вызове `f2[0]();` будет выведено `5`, а не `0`, как могло бы показаться на первый взгляд.
// -----
// ⋙ ❍ Ограничения для использования React хуков. Имеется ввиду где в коде компонента можно их использовать, а где нет и почему ✔
// Использование React хуков следует определенным правилам, которые обусловлены жизненным циклом компонента и правильной работой React. Вот основные ограничения и правила для использования React хуков:
// 1. Использование внутри компонента: Хуки следует использовать только внутри функциональных компонентов React или в кастомных хуках. Это означает, что вы можете использовать их внутри тела компонента, но не внутри циклов, условных операторов или внутри обычных JavaScript функций.
// 2. Не использовать внутри циклов или условных операторов: Поскольку порядок вызова хуков должен быть одинаковым при каждом рендере, использование их внутри циклов или условных операторов может нарушить это правило и привести к ошибкам.
// 3. Вызов хуков на верхнем уровне компонента: Хуки следует вызывать только на верхнем уровне компонента, то есть непосредственно в теле функционального компонента или внутри других кастомных хуков.
// 4. Не вызывать хуки из условий: При использовании условий, рендер компонента может зависеть от различных условий, и это может привести к непредсказуемому поведению хуков.
// 5. Исключения: Есть несколько специальных случаев, когда использование хуков внутри вложенных функций может быть допустимым (например, использование хука `useEffect` внутри колбэков или эффектов), но это требует внимания и понимания того, как работают хуки в React.
// Соблюдение этих ограничений помогает избежать ошибок и обеспечивает правильное поведение компонентов в React.
// -----
// ⋙ ❍ Как можно прокинуть value, чтобы получилось 2? ✔
// const [value, setValue] = useState(0);

// 1) setState(2);
// 2) setState(value + 1); setState(value + 1);
// 3) setState(value => value + 1); setState(value => value +1);

// const [value, setValue] = useState(0);

// 1) setState(2);
// 2) setState(value + 1); setState(value + 1);
// 3) setState(value => value + 1); setState(value => value +1);
// Для обоих вариантов прокидывания значения `value` в функцию `setState` в React можно использовать функциональный подход в `setState`.
// 1) setState(2):
// ```javascript
// setState(2);
// ```
// 2) setState(value + 1); setState(value + 1);:
// ```javascript
// setState(prevState => prevState + 1);
// setState(prevState => prevState + 1);
// ```
// 3) setState(value => value + 1); setState(value => value +1);:
// ```javascript
// setState(prevState => prevState + 1);
// setState(prevState => prevState + 1);
// ```
// В обоих случаях будет достигнуто значение `2`. Использование функционального подхода в `setState` гарантирует, что значение `value`, используемое для обновления состояния, будет актуальным на момент вызова функции `setState`.
// -----
// ⋙ ❍ Тайпскрипт. Как описать в интерфейсе компонента: ? ✔
// – value, которое может быть строкой или числом;
// – функцию getValue, которая возвращает value;
// – функцию setValue, которая принимает параметры и сетает value;
// Вот как можно описать интерфейс компонента в TypeScript:
// ```typescript
// interface MyComponent {
//   value: string | number;
//   getValue: () => string | number;
//   setValue: (newValue: string | number) => void;
// }
// ```
// В данном интерфейсе:
// - `value` имеет тип `string | number`, что означает, что он может быть строкой или числом.
// - `getValue` - это функция без параметров, которая возвращает значение типа `string | number`.
// - `setValue` - это функция, принимающая параметр `newValue` типа `string | number`, которая ничего не возвращает (`void`) и устанавливает новое значение для `value`.
// -----
// ⋙ ❍ Вопрос для рассуждения. Есть стор (Redux или MobX – не важно) и два подхода к хранению данных в нем: ✔
// 1) Все стейты вынесены в этот стор, компоненты не имеют локальных стейтов;
// 2) В стор вынесены всего два стейта, а остальное хранится в компонентах.
// Нужно рассказать о минусах таких подходов;
// Оба подхода имеют свои сильные и слабые стороны, и выбор между ними зависит от конкретной ситуации, требований проекта и предпочтений разработчиков. Давайте рассмотрим минусы каждого из подходов:
// 1) Все стейты вынесены в стор, компоненты не имеют локальных стейтов/Все стейты в сторе, без локальных стейтов в компонентах:
// - Усложнение логики в сторе: Когда все стейты хранятся в глобальном сторе, он может стать перегруженным и сложным для управления. В случае больших приложений это может привести к сложной логике обновления состояния и его мутации, что затрудняет отладку и поддержку кода.
// /- Усложнение управления глобальным состоянием.
// - Производительность: Если все стейты находятся в глобальном сторе, это может привести к избыточному перерендерингу компонентов из-за обновления любого значения в сторе, даже если это не приводит к изменениям в UI данного компонента. Это может отрицательно сказаться на производительности приложения.
// /- Возможные проблемы с производительностью из-за избыточных перерендеров.
// - Сложность масштабирования: При увеличении объема данных в сторе может стать сложнее управлять состоянием и поддерживать его консистентность. Это может стать проблемой при масштабировании приложения.
// /- Сложности масштабирования приложения.
// 2) В стор вынесены всего два стейта, а остальное хранится в компонентах/В сторе только два стейта, остальное в компонентах:
// - Дублирование данных и сложности с синхронизацией: Если множество компонентов содержит локальные стейты, это может привести к дублированию данных, особенно если одни и те же данные используются в нескольких компонентах. Это усложняет синхронизацию состояния между компонентами и может привести к ошибкам.
// - Сложность/Усложнение отслеживания состояния приложения: При наличии большого количества локальных стейтов в компонентах может быть сложно отследить, где и как изменяется состояние. Это может усложнить отладку и поддержку кода.
// - Ограниченный доступ к данным из других компонентов: Локальные стейты в компонентах могут быть недоступны из других компонентов, что усложняет передачу данных и взаимодействие между ними.
// В обоих случаях важно находить баланс между централизованным и децентрализованным хранением данных, и выбирать подход в зависимости от конкретных потребностей проекта.
// -----
// ⋙ ❍ Что появится в DOMе если вызвать компоненты следующим образом: ✔
// <>
//   <name/>
//   <User/>
// <>
// 1
// 2
// 3
// 4
// <>
//   <name/>
//   <User/>
// <>
// Если вы вызовете компоненты `<name/>` и `<User/>` в контексте JSX без явного закрытия тега (например, в React), то они будут интерпретированы как пустые элементы самозакрывающегося тега. Таким образом, они не будут иметь закрывающего тега, а их содержимым будет `null`. Вот как это будет выглядеть в DOM:
// ```html
// <>
//   <name/>
//   <User/>
// </>
// ```

// ```html
// <div>
//   <name></name>
//   <User></User>
// </div>
// ```
// В этом примере `<name/>` и `<User/>` - это пустые компоненты, которые будут вставлены в DOM без содержимого.
// -----
// ⋙ ❍ Кастомные тег, компонент или ошибка? примеры ✔
// Вот примеры:
// 1. Кастомный тег:
// ```html
// <x-custom-tag></x-custom-tag>
// ```
// Это кастомный тег, так как он не является стандартным HTML-тегом, но может использоваться в веб-разработке для добавления собственных функциональных элементов.
// 2. Компонент:
// ```html
// <my-custom-component></my-custom-component>
// ```
// Это может быть как кастомный тег, представляющий компонент, так и настоящий компонент, реализованный с помощью фреймворка или библиотеки, таких как React, Vue или Angular. В компонентах обычно содержится какая-то логика, стили и разметка, которые могут быть повторно использованы.
// 3. Ошибка:
// ```html
// <custom-component>
// ```
// Если это не определенный кастомный тег или компонент, а просто опечатка или неверное использование, то это может рассматриваться как ошибка.
// -----
// ⋙ ❍ CSS-свойства, которые нежелательно использовать для анимации элементов, т.к. они будут вызывать перерисовку ✔
// CSS-свойства, которые могут вызывать перерисовку элементов и, следовательно, не рекомендуется их использовать для анимации, включают:
// 1. width и height: Изменение размеров элемента может вызывать/вызывает перерисовку всего содержимого на странице.
// 2. top, left, right и bottom: Анимация изменения позиции элемента может вызывать перерисовку всего содержимого на странице.
// 3. margin и padding: Изменение отступов также может вызывать перерисовку окружающих элементов.
// 4. display: Переключение между значениями `block`, `inline`, `inline-block` и другими может вызывать перерисовку.
// 5. position: Анимация изменения позиционирования элемента может вызвать перерисовку окружающих элементов.
// 6. border-radius: Изменение радиуса скругления углов также может вызывать перерисовку элемента.
// 7. background: Анимация изменения фона элемента может вызывать перерисовку всего содержимого на странице.
// Вместо использования этих свойств для анимации, рекомендуется использовать свойства, которые не вызывают перерисовку, такие как `transform` и `opacity`. Использование аппаратного ускорения с помощью `transform: translateZ(0)` также может помочь улучшить производительность анимации.
// -----
// ⋙ ❍ Какие свойства нельзя назначать для блока если мы используем БЭМ-методологию? ✔
// При использовании методологии БЭМ (Блок-Элемент-Модификатор) рекомендуется избегать назначения следующих свойств для блока:
// 1. Свойства, описывающие внешний вид элемента/Свойства внешнего вида:
// - `margin`, `padding`, `width`, `height` и другие свойства, описывающие размеры и отступы блока. Эти свойства лучше использовать для модификаторов или элементов, если это необходимо.
// /Не назначайте размеры (`width`, `height`), отступы (`margin`, `padding`) и рамки (`border`) блока.
// 2. Свойства, определяющие расположение блока/Свойства позиционирования:
// - `position`, `top`, `left`, `right`, `bottom`, `float` и другие свойства, определяющие позиционирование блока на странице. Блоки в БЭМ следует позиционировать с помощью других сущностей БЭМ, таких как модификаторы или дополнительные элементы.
// /Избегайте назначения позиционирующих свойств (`position`, `top`, `left`, `right`, `bottom`).
// 3. Свойства, описывающие визуальное оформление/Свойства визуального оформления:
// - `background-color`, `border`, `box-shadow`, `text-align` и другие свойства, определяющие внешний вид блока. Эти свойства также лучше использовать для модификаторов или элементов.
// /Не используйте свойства, определяющие фон (`background-color`), тени (`box-shadow`) и выравнивание текста (`text-align`).
// 4. Свойства, определяющие шрифт/Свойства шрифта:
// - `font-family`, `font-size`, `font-weight`, `line-height` и другие свойства, определяющие шрифт и размер текста. Если требуется изменить шрифт для блока, рекомендуется использовать модификатор или дополнительный элемент.
// Используя БЭМ-методологию, стили блока должны быть независимыми от контекста использования блока, что упрощает переиспользование и поддержку стилей.
// /Избегайте назначения шрифтов и размеров текста (`font-family`, `font-size`) для блока.
// Вместо этого используйте модификаторы и элементы для изменения стиля и внешнего вида блока в соответствии с принципами БЭМ.
// -----
// ⋙ ❍ Вес селекторов. С каким цветом будет отображаться текст? ✔
// <div id="id" class="class">
//   <span>Some text</span>
// </div>
// .class span {color: red};
// #p > span {color: green};
// #p span {color: blue};
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// <div id="id" class="class">
//   <span>Some text</span>
// </div>
// .class span {color: red};
// #p > span {color: green};
// #p span {color: blue};
// Селекторы в CSS имеют различный вес в зависимости от их специфичности. Более специфичные селекторы имеют более высокий вес и переопределяют стили менее специфичных селекторов.
// В данном случае:
// 1. `.class span {color: red};` - селектор имеет вес 2 (комбинированный селектор), цвет текста устанавливается как красный.
// 2. `#p > span {color: green};` - селектор имеет вес 101 (ID селектор с дочерним элементом), но нет элемента с ID `p`, поэтому это правило не применяется.
// 3. `#p span {color: blue};` - селектор имеет вес 100 (ID селектор), но нет элемента с ID `p`, поэтому это правило не применяется.
// Таким образом, текст будет отображаться красным, так как это правило имеет более высокий вес.
// -----
// ⋙ ❍ Есть элемент, стилизованная под ссылку и элемент, стилизованная под кнопку. Первый элемент открывает попап, второй – редиректит юзера на страницу с корзиной. Какие теги нужно использовать в этих случаях? ✔
// Для открытия попапа чаще всего используется тег `<a>` с атрибутом `href`, который указывает на адрес страницы или якорь, а для редиректа на другую страницу - также тег `<a>` с атрибутом `href`, но с указанием адреса страницы, куда нужно перенаправить пользователя. Вот примеры:
// 1. Открытие попапа:
// ```html
// <a href="#popup" class="popup-link">Открыть попап</a>
// ```
// где `#popup` - это якорь, указывающий на блок с попапом.
// 2. Редирект на страницу с корзиной:
// ```html
// <a href="/cart" class="button">Перейти в корзину</a>
// ```
// где `"/cart"` - это адрес страницы с корзиной.
// Также можно использовать кнопку `<button>`, но в данном случае, когда нет необходимости в отправке формы, тег `<a>` является более уместным, так как его прямое использование для ссылок на внешние ресурсы или якори улучшает доступность для пользователей и поисковых систем.
// -----
// ⋙ ❍ Браузерные способы хранения информации (cookies, session storage, local storage) и их основные различия? ✔
// Браузерные способы хранения информации - это механизмы, предоставляемые браузером для сохранения данных на стороне клиента. Они включают в себя cookies, session storage и local storage. Вот их основные различия:
// 1. Cookies:
// - Cookies - это маленькие текстовые файлы, которые хранятся на компьютере пользователя.
// - Они отправляются браузером на сервер при каждом HTTP запросе, включая запросы изображений, стилей и скриптов, что может замедлить загрузку страницы.
// - Cookies имеют ограничения по размеру (обычно до 4 КБ) и по количеству (обычно до 50 cookies на домен).
// - Cookies можно устанавливать с определенным сроком жизни (persistent cookies) или на время сеанса (session cookies).
// Кратко:
// - Маленькие текстовые файлы, сохраняемые на компьютере пользователя.
// - Отправляются на сервер с каждым HTTP запросом.
// - Ограничены по размеру и количеству.
// - Могут быть постоянными (с определенным сроком жизни) или временными (на время сеанса).
// 2. Session Storage:
// - Session storage - это механизм хранения данных, доступный только для текущего сеанса браузера.
// - Данные session storage сохраняются только в течение времени жизни текущего окна или вкладки браузера. При закрытии окна или вкладки данные будут удалены.
// - Ограничения по размеру обычно зависят от браузера и составляют несколько мегабайт.
// - Данные session storage доступны только в рамках текущей вкладки или окна браузера и не видны в других вкладках или окнах.
// Кратко:
// - Хранит данные только в течение сеанса браузера.
// - Данные доступны только в рамках текущего окна или вкладки.
// - Удаляется при закрытии окна или вкладки.
// 3. Local Storage:
// - Local storage - это механизм хранения данных, доступный для постоянного хранения на стороне клиента.
// - Данные local storage сохраняются даже после закрытия браузера и могут быть доступны при следующем визите на веб-сайт.
// - Ограничения по размеру обычно составляют несколько мегабайт (обычно около 5 МБ).
// - Данные local storage доступны для всех вкладок и окон, открытых на одном и том же домене.
// Кратко:
// - Позволяет хранить данные на долгосрочной основе.
// - Данные доступны для всех вкладок и окон на одном домене.
// - Сохраняется даже после закрытия браузера.
// В общем, cookies используются для хранения небольших данных, которые требуется отправлять на сервер с каждым запросом, session storage - для временного хранения данных в рамках текущего сеанса браузера, а local storage - для долгосрочного хранения данных на стороне клиента.
// --------------------------------------------------------------------------------------------
// [РЕАЛЬНЫЕ ЗАДАЧИ JUNIOR]:
// ---------------------
// ⋙ ❍ В чем разница между использованием «var», «let» и «const»? ✔
// В JavaScript различают три способа объявления переменных: `var`, `let` и `const`. Вот основные различия между ними:
// 1. var:
// - Переменные, объявленные с помощью `var`, имеют функциональную область видимости или область видимости внутри функции.
// - Они могут быть переобъявлены и переназначены.
// - При использовании `var` переменная поднимается (hoisting) вверх области видимости, что может привести к неожиданным результатам.
// Пример:
// ```javascript
// var x = 10;
// console.log(x); // Выведет 10

// // Переобъявление
// var x = 20;
// console.log(x); // Выведет 20
// ```
// 2. let:
// - Переменные, объявленные с помощью `let`, имеют блочную область видимости (область видимости внутри блока `{}`).
// - Они не могут быть переобъявлены, но могут быть переназначены.
// - Переменные, объявленные с помощью `let`, не поднимаются вверх блока (нет hoisting).
// Пример:
// ```javascript
// let y = 10;
// console.log(y); // Выведет 10

// // Ошибка: Переменная уже была объявлена
// let y = 20;
// console.log(y);
// ```
// 3. const:
// - Переменные, объявленные с помощью `const`, также имеют блочную область видимости.
// - Они не могут быть ни переобъявлены, ни переназначены после инициализации. Однако содержимое объекта или массива, объявленного с помощью `const`, может быть изменено.
// - Переменные, объявленные с помощью `const`, также не поднимаются вверх блока (нет hoisting).
// Пример:
// ```javascript
// const z = 10;
// console.log(z); // Выведет 10

// // Ошибка: Переменная уже была объявлена
// const z = 20;
// console.log(z);
// ```
// В целом, рекомендуется использовать `const` по умолчанию, если переменная не должна изменяться, и только использовать `let`, когда необходимо переопределить переменную. Использование `var` лучше избегать из-за его неинтуитивного поведения, связанного с поднятием переменных (hoisting).
// -----
// ⋙ ❍ Как показать пользователю уведомление о том, что в его браузере не включен javascript? ✔
// Чтобы показать пользователю уведомление о том, что в его браузере JavaScript отключен, вы можете использовать тег `<noscript>` в HTML для вывода сообщения, которое будет видно только в случае отключенного JavaScript. Вот пример:
// ```html
// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>Уведомление о JavaScript</title>
//     <style>
//         .noscript-message {
//             display: none; /* Скрываем по умолчанию */
//             background-color: #f8d7da;
//             border: 1px solid #f5c6cb;
//             color: #721c24;
//             padding: 10px;
//             margin-bottom: 20px;
//         }
//     </style>
//     <script>
//         // Скрываем сообщение, если JavaScript включен
//         document.addEventListener('DOMContentLoaded', function() {
//             var noscriptMessage = document.querySelector('.noscript-message');
//             noscriptMessage.style.display = 'none';
//         });
//     </script>
// </head>
// <body>
//     <!-- Сообщение для отключенного JavaScript -->
//     <noscript class="noscript-message">
//         <p>JavaScript отключен в вашем браузере. Для корректной работы этого сайта, вам необходимо включить JavaScript.</p>
//     </noscript>

//     <!-- Ваш контент здесь -->
//     <h1>Добро пожаловать на сайт!</h1>
//     <p>Здесь ваш контент.</p>
// </body>
// </html>
// ```
// Этот код покажет уведомление в теге `<noscript>`, если JavaScript отключен в браузере пользователя. Когда JavaScript включен, это сообщение будет скрыто.
// /Чтобы показать пользователю уведомление о том, что в его браузере не включен JavaScript, можно использовать тег `<noscript>` в HTML. Этот тег используется для предоставления контента, который будет отображаться только в случае, если JavaScript отключен или не поддерживается. Вот пример:
// ```html
// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>Уведомление о JavaScript</title>
// </head>
// <body>
//     <noscript>
//         <div style="background-color: #f8d7da; color: #721c24; padding: 10px;">
//             Для корректной работы этого сайта необходимо включить JavaScript в вашем браузере.
//         </div>
//     </noscript>
//     <div id="app">
//         <!-- Содержимое вашего приложения -->
//     </div>
//     <!-- Ваши скрипты JavaScript -->
// </body>
// </html>
// ```
// Этот код покажет сообщение "Для корректной работы этого сайта необходимо включить JavaScript в вашем браузере", если JavaScript отключен или не поддерживается в браузере пользователя.
// -----
// ⋙ ❍ Почему важен порядок добавления скриптов на страницу? ✔
// Порядок добавления скриптов на страницу важен из-за того, что JavaScript выполняется последовательно, по мере загрузки и интерпретации страницы браузером. Вот несколько причин, почему порядок добавления скриптов имеет значение:
// 1. Зависимости между скриптами: Если один скрипт зависит от другого, то порядок их загрузки должен быть правильным, чтобы гарантировать корректное выполнение. Например, если скрипт A использует функции или переменные из скрипта B, то скрипт B должен быть загружен и выполнен до скрипта A.
// 2. Использование DOM элементов: Если скрипты взаимодействуют с DOM элементами страницы, то они должны быть загружены после того, как соответствующие элементы будут созданы и доступны для использования.
// 3. Время выполнения: Некоторые скрипты могут выполняться немедленно после загрузки страницы, поэтому порядок их загрузки может повлиять на то, когда они начнут работу. Например, скрипты, выполняющиеся в событии `DOMContentLoaded`, будут выполняться после загрузки и парсинга DOM.
// 4. Конфликты имен: Если несколько скриптов определяют одинаковые имена функций или переменных, то последний загруженный скрипт перезапишет предыдущие определения, что может привести к ошибкам или непредвиденному поведению.
// Поэтому важно следить за порядком загрузки и исполнения скриптов на странице, чтобы избежать проблем и обеспечить корректную работу вашего веб-приложения.
// -----
// ⋙ ❍ Как получить текущий URL? ✔
// В браузерной среде JavaScript можно получить текущий URL с помощью объекта `window.location`. Вот несколько способов получения текущего URL:
// 1. window.location.href: Это свойство возвращает полный URL текущей страницы в виде строки.
// ```javascript
// var currentUrl = window.location.href;
// console.log(currentUrl);
// ```
// 2. window.location.toString(): Этот метод возвращает текущий URL в виде строки.
// ```javascript
// var currentUrl = window.location.toString();
// console.log(currentUrl);
// ```
// 3. window.location.pathname: Это свойство возвращает часть URL после домена (т.е. путь к текущему ресурсу).
// ```javascript
// var pathName = window.location.pathname;
// console.log(pathName);
// ```
// 4. window.location.origin: Это свойство возвращает протокол, хост и порт текущего URL.
// ```javascript
// var origin = window.location.origin;
// console.log(origin);
// ```
// Каждый из этих способов позволяет получить различные части текущего URL в зависимости от потребностей вашего приложения.
// -----
// ⋙ ❍ Как проверить, что переменная не является неопределенной? Как проверить, что свойство существует в объекте? ✔
// Чтобы проверить, что переменная не является неопределенной (undefined), можно использовать условное выражение с оператором строгого сравнения (===) или оператором typeof. Вот примеры:
// 1. Оператор typeof:
// ```javascript
// if (typeof myVar !== 'undefined') {
//     // myVar не является неопределенной
//     console.log('Переменная определена');
// } else {
//     console.log('Переменная неопределена');
// }
// ```
// 2. Оператор строгого сравнения (===):
// ```javascript
// if (myVar !== undefined) {
//     // myVar не является неопределенной
//     console.log('Переменная определена');
// } else {
//     console.log('Переменная неопределена');
// }
// ```
// Чтобы проверить, что свойство существует в объекте, можно использовать оператор in или метод hasOwnProperty(). Вот примеры:
// 1. Оператор in:
// ```javascript
// if ('propertyName' in myObject) {
//     // Свойство существует в объекте
//     console.log('Свойство существует');
// } else {
//     console.log('Свойство не существует');
// }
// ```
// 2. Метод hasOwnProperty():
// ```javascript
// if (myObject.hasOwnProperty('propertyName')) {
//     // Свойство существует в объекте
//     console.log('Свойство существует');
// } else {
//     console.log('Свойство не существует');
// }
// ```
// В обоих случаях, если свойство 'propertyName' существует в объекте myObject, будет выполнен блок кода внутри условия, иначе будет выполнен блок кода после else.
// -----
// ⋙ ❍ Написать простую функцию, чтобы проверить, является ли число целым? ✔
// Вот пример простой функции на JavaScript, которая проверяет, является ли число целым:
// ```javascript
// function isInteger(number) {
//     return Number.isInteger(number);
// }

// // Пример использования:
// console.log(isInteger(5)); // true
// console.log(isInteger(3.14)); // false
// ```
// Эта функция использует метод `Number.isInteger()`, который возвращает `true`, если переданное значение является целым числом, и `false` в противном случае.
// -----
// ⋙ ❍ Как остановить функцию setInterval? ✔
// Чтобы остановить выполнение функции, запущенной с помощью `setInterval()` в JavaScript, можно использовать функцию `clearInterval()`. Эта функция принимает идентификатор интервала, который был возвращен при вызове `setInterval()`, и останавливает выполнение соответствующего интервала. Вот пример:
// ```javascript
// // Запуск функции с интервалом 1 секунда
// let intervalId = setInterval(function() {
//     console.log('Функция выполняется каждую секунду');
// }, 1000);

// // Через 5 секунд остановить выполнение функции
// setTimeout(function() {
//     clearInterval(intervalId); // Остановить выполнение функции с интервалом
//     console.log('Функция остановлена');
// }, 5000);
// ```
// В этом примере, после запуска функции с помощью `setInterval()`, ее выполнение останавливается через 5 секунд с помощью `clearInterval()` и идентификатора интервала `intervalId`.
// -----
// ⋙ ❍ Список примитивных типов в JavaScript ✔
// В JavaScript есть несколько примитивных типов данных:
// 1. Число (Number): Представляет числовые значения, как целые, так и с плавающей точкой. Пример: `42`, `3.14`.
// 2. Строка (String): Представляет текстовые данные. Строки могут быть заключены в одинарные или двойные кавычки. Пример: `"Hello, world!"`.
// 3. Логическое значение (Boolean): Представляет собой логическое значение `true` или `false`, используемое для логических операций. Пример: `true`.
// 4. Null: Представляет отсутствие значения или "ничто". Пример: `null`.
// 5. Undefined: Представляет неопределенное значение, когда переменная была объявлена, но ей не было присвоено значение. Пример: `undefined`.
// 6. Символ (Symbol): Представляет уникальный и неизменяемый идентификатор, используемый, например, для создания свойств объектов с уникальными ключами. Пример: `Symbol('description')`.
// Это основные примитивные типы данных в JavaScript.
// -----
// ⋙ ❍ Что такое функция имени в JavaScript и как ее определить? ✔
// Именованная функция в JavaScript - это функция, имеющая определенный идентификатор. Он определяется с помощью ключевого слова `function`, за которым следует название функции и параметры, если таковые имеются. Вот краткий пример:
// /Именованные функции полезны для организации кода, удобства чтения и повторного использования. Они могут быть определены в любом месте вашего кода JavaScript, а их имена привязаны к содержащему их блоку или функции, что делает их доступными в пределах этой области.
// ``
// функция javascript functionName(параметры) {
//   // Функциональный орган
// }
// ```
// Например:
// ``
// функция javascript получает(имя) {
//   возвращает "Привет", "+ имя + "!";
// }
// ```
// Затем вы можете вызвать эту функцию по ее имени, например, так: "great("Джон")`.
// --------------------------------------------------------------------------------------------
// [ПРАВИЛЬНЫЕ ОТВЕТЫ НА ЗАДАЧИ]:
// ---------------------
// ⋙ ❍ Разница в уровне охвата? ✔
// Var – Оператор переменных JavaScript используется для объявления переменной и, при желании, мы можем инициализировать значение этой переменной.
// var a = 10;
// Объявления переменных обрабатываются перед выполнением кода.
// Const – идея константных функций не позволяет им изменять объект, для которого они вызываются. Когда функция объявлена ​​как const, ее можно вызывать для любого типа объекта.
// Let – это сигнал о том, что переменная может быть переназначена, например, счетчик в цикле или замена значения в алгоритме. Он также сигнализирует, что переменная будет использоваться только в блоке, в котором она определена.
// -----
// ⋙ ❍ Показать пользователю уведомление о том, что в его браузере не включен JavaScript? ✔
// <noscript>Your browser does not support JavaScript!</noscript>
// -----
// ⋙ ❍ Библиотеки следует добавлять раньше, чем скрипты, которые их используют ✔
// Например, следующий фрагмент приведет к ошибке «Uncaught ReferenceError: jQuery is not defined»
// <script src="js/jquery.easing.js"></script>
// <script src="js/jquery.js"></script>
// -----
// ⋙ ❍ Получить текущий URL ✔
// window.location.href
// document.URL
// -----
// ⋙ ❍ Проверить, что переменная не является неопределенной, что свойство существует в объекте ✔
//  if (typeof someVar !== "undefined") {
//     // делаем что-то
// }
// проверяем свойство с наследованием
// if ('someProperty' in object) {
//     // делаем что-то
// }
// проверяем свойство без наследования
// if (object.hasOwnProperty('someProperty')) {
//     // делаем что-то
// }
// -----
// ⋙ ❍ Функция, чтобы проверить, является ли число целым? ✔
// function verifyInt(num) {
//   return num % 1 === 0;
// }
// Функция `verifyInt`, представленная вами, корректно проверяет, является ли число целым, используя операцию остатка от деления. Однако можно рассмотреть также другие способы выполнения этой проверки. Давайте сначала посмотрим на вашу функцию, а затем на альтернативные варианты.
// Ваша функция
// ```javascript
// function verifyInt(num) {
//   return num % 1 === 0;
// }
// ```
// Эта функция возвращает `true`, если остаток от деления числа `num` на `1` равен `0`, что означает, что `num` является целым числом. Это работает, потому что для любого целого числа остаток от деления на 1 всегда будет равен 0.
// Альтернативные способы проверки
// 1. Использование `Number.isInteger`:
//    Встроенный метод `Number.isInteger` в JavaScript проверяет, является ли значение целым числом.
//  ```javascript
//  function verifyInt(num) {
//    return Number.isInteger(num);
//  }
//  ```
// 2. Использование метода `Math.floor`:
//    Если число равно его целой части, то оно является целым числом.
//  ```javascript
//  function verifyInt(num) {
//    return Math.floor(num) === num;
//  }
//  ```
// 3. Сравнение с приведенным к целому числу значением:
//    Использование побитового оператора НЕ (`~~`) или метода `parseInt`.
//  ```javascript
//  function verifyInt(num) {
//    return ~~num === num;
//  }
//  ```
// Или
//  ```javascript
//  function verifyInt(num) {
//    return parseInt(num, 10) === num;
//  }
//  ```
// Каждый из этих методов имеет свои преимущества, но все они проверяют одно и то же условие — является ли число целым. В реальных приложениях рекомендуется использовать встроенные методы, такие как `Number.isInteger`, так как они наиболее читаемы и понятны.
// Полный код с альтернативами
// Вот несколько реализаций функции проверки целого числа:
// ```javascript
// Вариант 1: Ваш метод с использованием остатка от деления
// function verifyInt(num) {
//   return num % 1 === 0;
// }
// Вариант 2: Использование Number.isInteger
// function verifyInt(num) {
//   return Number.isInteger(num);
// }
// Вариант 3: Использование Math.floor
// function verifyInt(num) {
//   return Math.floor(num) === num;
// }
// Вариант 4: Использование побитового оператора НЕ
// function verifyInt(num) {
//   return ~~num === num;
// }
// Вариант 5: Использование parseInt
// function verifyInt(num) {
//   return parseInt(num, 10) === num;
// }
// ```
// Вы можете выбрать любой из этих методов в зависимости от ваших предпочтений и требований вашего проекта.
// -----
// ⋙ ❍ Остановить функцию setInterval ✔
// повторяем с интервалом в 1 секунду
// let intervalId = setInterval(() => console.log('tick'), 1000);
// остановимся через 10 секунд
// setTimeout(() => { clearInterval(intervalId); console.log('stop'); }, 10000);
// -----
// ⋙ ❍ Список примитивных типов ✔
// Тип числа представляет как целые числа, так и числа с плавающей запятой.
// Тип строки должен быть заключен в кавычки.
// Логический тип имеет только два значения: true и false.
// -----
// ⋙ ❍ В чем разница между Java и JavaScript? ✔
// Язык программирования JavaScript разработан Netscape, Inc и не является частью платформы Java.
// Приложения Java запускаются на виртуальной машине или в веб-браузере, а JavaScript – в веб-браузере и некоторых серверных средах.
// Код Java компилируется, тогда как код JavaScript находится в тексте и на веб-странице.
// JavaScript – это язык сценариев ООП, тогда как Java – язык программирования ООП.
// -----
// ⋙ ❍ Функция имени ✔
// Именованная функция объявляет имя, как только оно определено. Ее можно определить с помощью ключевого слова функции как:
// function named(){
// write code here
// }
// Именованные функции определяются с помощью ключевого слова `function`, за которым следует имя функции. Вот пример именованной функции:
// ```javascript
// function named() {
//     // Код функции
// }
// ```
// Имя функции (`named` в этом случае) является идентификатором, который можно использовать для вызова функции из других частей кода, а также для рекурсивных вызовов функции (если необходимо).
// /Вот пример определения именованной функции с использованием ключевого слова `function`:
// ```javascript
// function named(){
//     console.log("This is a named function");
// }
// ```
// Этот код определяет именованную функцию с именем `named`, которая просто выводит сообщение в консоль. После определения функции вы можете вызвать ее по имени, например:
// ```javascript
// named(); // Вызовет функцию и выведет "This is a named function" в консоль
// ```
// ---------------------------------------------------------------------------------------------
// [РЕАЛЬНЫЕ ЗАДАЧИ MIDDLE !]:
// ---------------------
// ✎ Иногда Javascript ведет себя не совсем очевидно. Разработчик должен знать правила, по которым выполняется преобразование типов во время выполнения операций. Знание правил может предотвратить множество ошибок.
// ✎ Примеры кода, результат выполнения которого должен быть очевиден для разработчика:
// ---------------------
// ⋙ ❍ Преобразование типов ✔
// Преобразование типов в JavaScript может происходить автоматически (неявное) или явным образом (явное). Вот основные способы преобразования типов:
// 1. Неявное преобразование типов/Неявным (автоматическим): Это автоматическое преобразование типов, которое выполняется JavaScript при выполнении операций или сравнении значений разных типов.
// /Происходит автоматически при выполнении операций или сравнении значений разных типов.
// Примеры:
// ```javascript
// // Строковое преобразование
// var num = 10;
// var str = "Number is: " + num; // num неявно преобразуется в строку

// // Арифметическое преобразование
// var result = "3" * 2; // "3" неявно преобразуется в число
// ```
// 2. Явное преобразование типов/Явным (эксплицитным): Это преобразование типов, которое выполняется с помощью встроенных функций или операторов.
// /Происходит с помощью встроенных функций или операторов, когда требуется явно указать тип данных.
// Примеры:
// ```javascript
// // Преобразование в число
// var str = "42";
// var num = parseInt(str);

// // Преобразование в строку
// var num = 42;
// var str = num.toString();
// ```
// Необходимость в явном преобразовании типов может возникнуть, когда требуется точный контроль над типами данных или когда необходимо привести данные к определенному формату для их обработки.
// ---------------------
// ⋙ ❍ 5 + ‘2’ Что на выходе? ✔
// `5 + '2'` выведет `"52"`. При использовании оператора `+` со строкой JavaScript преобразует число в строку, и происходит конкатенация строк, а не сложение чисел.
// -----
// ⋙ ❍ 5 – «2» Что на выходе? ✔
// `5 - '2'` выведет `3`. При использовании оператора `-` JavaScript пытается преобразовать строку в число и выполняет вычитание.
// -----
// ⋙ ❍ true + true Что на выходе? ✔
// `true + true` выведет `2`. При попытке использования оператора `+` со значениями `true`, JavaScript автоматически преобразует `true` в число, где `true` равно `1`, поэтому `true + true` равно `1 + 1`, что дает `2`.
// /JavaScript выполнит автоматическое преобразование типов данных в этих операциях:
// 1. `5 + '2'`: Оператор `+` используется для сложения чисел и строк. Поскольку один из операндов (строка `'2'`) является строкой, JavaScript выполнит конкатенацию и преобразует число 5 в строку, результат будет строкой `'52'`.
// 2. `5 - '2'`: Оператор `-` используется для вычитания чисел. JavaScript автоматически преобразует строку `'2'` в число, результатом будет число `3`.
// 3. `true + true`: Оператор `+` используется для сложения чисел. Логические значения `true` и `false` в JavaScript могут быть преобразованы в числа 1 и 0 соответственно. Поэтому `true + true` преобразуется в `1 + 1`, результатом которого будет число `2`.
// Итак, результаты будут:
// 1. `'52'`
// 2. `3`
// 3. `2`
// -----
// ⋙ ❍ Promise ✔
// Promise - это объект в JavaScript, представляющий асинхронную операцию, которая может завершиться успешно (выполниться) или с ошибкой (отклониться). Он используется для управления асинхронными операциями и обработки их результатов в будущем.
// Promise имеет три состояния:
// 1. Pending (ожидание): Начальное состояние, когда асинхронная операция еще не завершена.
// 2. Fulfilled (выполнено): Состояние, когда асинхронная операция завершилась успешно.
// 3. Rejected (отклонено): Состояние, когда асинхронная операция завершилась с ошибкой.
// Promise обладает методами для добавления обработчиков для успешного завершения (`then`) и для обработки ошибок (`catch`). Эти методы позволяют структурировать асинхронный код таким образом, что он становится более понятным и управляемым.
// Пример использования Promise был показан в предыдущем ответе, где асинхронная операция (задержка) обернута в Promise, а затем последовательно вызываются операции через цепочку методов `then`.
// -----
// ⋙ ❍ Перепишите пример, используя promise: ✔
// const printSec = (number, callback) => {
//   setTimeout(() => {
//       console.log(`${number} sec`)
//       callback()
//     },
//     1000)
// }
// printSec(1, () => {
//   printSec(2, () => {
//     printSec(3, () => {})
//   })
// })
// Вот пример переписанного кода с использованием промисов:
// ```javascript
// const printSec = (number) => {
//     return new Promise((resolve, reject) => {
//         setTimeout(() => {
//             console.log(`${number} sec`);
//             resolve();
//         }, 1000);
//     });
// };

// printSec(1)
//     .then(() => {
//         return printSec(2);
//     })
//     .then(() => {
//         return printSec(3);
//     })
//     .then(() => {
//         // Код для завершения цепочки промисов
//     })
//     .catch((error) => {
//         console.error('Произошла ошибка:', error);
//     });
// ```
// В этом примере:
// - Функция `printSec` возвращает новый промис, который завершится через заданное количество секунд.
// - После каждого завершения промиса вызывается следующий промис через метод `then`.
// - Метод `catch` используется для обработки любых ошибок, которые могут возникнуть в процессе выполнения промисов.
// /1. `printSec` теперь возвращает промис, который выполнится через одну секунду.
// 2. Мы используем метод `then`, чтобы вызывать `printSec` для каждой секунды по порядку.
// 3. Каждый вызов `printSec` будет дожидаться завершения предыдущего, благодаря цепочке методов `then`.
// 4. После завершения всех промисов, мы выводим сообщение "All seconds printed".
// -----
// ⋙ ❍ Как работает прототип? ✔
// Прототип в JavaScript - это механизм, позволяющий объектам наследовать свойства и методы других объектов.
// Каждый объект в JavaScript имеет свойство `prototype`, которое указывает на другой объект, называемый прототипом. Когда свойство или метод вызывается у объекта, JavaScript сначала ищет его в самом объекте. Если свойство не найдено, JavaScript будет искать его в прототипе объекта. Этот процесс может продолжаться до тех пор, пока не будет найдено свойство или будет достигнут конечный прототип `null`.
// Прототипы используются для создания наследования в JavaScript. Когда объект наследует свойства и методы от своего прототипа, он может использовать их, как если бы они были его собственными. Это позволяет избегать дублирования кода и создавать более гибкую иерархию объектов.
// Вот простой пример цикла событий на JavaScript:
// ```javascript
// // Создаем обработчик события
// function eventHandler() {
//     console.log('Событие обработано!');
// }

// // Добавляем обработчик события к элементу
// document.getElementById('myButton').addEventListener('click', eventHandler);

// // Создаем событие, которое будет помещено в очередь событий
// document.getElementById('myButton').click();

// // Цикл событий обрабатывает события из очереди
// ```
// В этом примере:
// 1. Мы создаем обработчик события `eventHandler`, который просто выводит сообщение в консоль.
// 2. Затем мы добавляем этот обработчик к элементу с идентификатором `myButton`, который, например, может быть кнопкой на странице.
// 3. После этого мы создаем и программно вызываем событие `click` для кнопки `myButton`.
// 4. Это событие добавляется в очередь событий браузера.
// 5. Цикл событий браузера обрабатывает события из очереди, и обработчик `eventHandler` выполняется, выводя сообщение в консоль.
// Это демонстрирует базовый принцип работы цикла событий: события добавляются в очередь, а затем обрабатываются одно за другим.
// -----
// ⋙ ❍ Цикл событий ✔
// Вот простой пример цикла событий на JavaScript:
// ```javascript
// // Создаем обработчик события
// function eventHandler() {
//     console.log('Событие обработано!');
// }

// // Добавляем обработчик события к элементу
// document.getElementById('myButton').addEventListener('click', eventHandler);

// // Создаем событие, которое будет помещено в очередь событий
// document.getElementById('myButton').click();

// // Цикл событий обрабатывает события из очереди
// ```
// В этом примере:
// 1. Мы создаем обработчик события `eventHandler`, который просто выводит сообщение в консоль.
// 2. Затем мы добавляем этот обработчик к элементу с идентификатором `myButton`, который, например, может быть кнопкой на странице.
// 3. После этого мы создаем и программно вызываем событие `click` для кнопки `myButton`.
// 4. Это событие добавляется в очередь событий браузера.
// 5. Цикл событий браузера обрабатывает события из очереди, и обработчик `eventHandler` выполняется, выводя сообщение в консоль.
// Это демонстрирует базовый принцип работы цикла событий: события добавляются в очередь, а затем обрабатываются одно за другим.
// -----
// ⋙ ❍ Что произойдет со страничкой в результате выполнения этого кода? ✔
// function foo() {
//     setTimeout(foo, 0);
// }
// foo();
// Этот код создает бесконечно рекурсивную функцию `foo`, которая будет вызывать саму себя с помощью `setTimeout` с нулевой задержкой. Это означает, что функция `foo` будет вызываться снова и снова, практически мгновенно.
// В результате выполнения этого кода произойдет блокировка интерфейса браузера, так как браузер будет занят вызовом `foo` снова и снова, не давая браузеру выполнить другие задачи или обновить интерфейс страницы. Это приведет к зависанию или краху страницы.
// Этот код представляет собой пример бесконечного цикла, который не завершится никогда, пока браузер не перестанет отвечать из-за перегрузки стека вызовов.
// -----
// ⋙ ❍ Как найти сумму элементов массива, если вложенность массива неизвестна? ✔
// arraySum([[1, 2, [3, 4]], [9], [10, 12]])
// [ОТВЕТ НИЖЕ В ПРАВИЛЬНЫХ ОТВЕТАХ] или следом:
// /Для нахождения суммы элементов массива с неизвестной вложенностью можно использовать рекурсивную функцию, которая будет перебирать все элементы массива и рекурсивно обрабатывать вложенные массивы. Вот пример такой функции:
// ```javascript
// function arraySum(arr) {
//     let sum = 0;
//     arr.forEach((item) => {
//         if (Array.isArray(item)) {
//             sum += arraySum(item); // Рекурсивно вызываем arraySum для вложенного массива
//         } else {
//             sum += item; // Если элемент не массив, просто добавляем его к сумме
//         }
//     });
//     return sum;
// }
// console.log(arraySum([[1, 2, [3, 4]], [9], [10, 12]])); // Выведет 41
// ```
// Этот код рекурсивно перебирает все элементы массива, и если элемент является массивом, вызывает `arraySum` для этого массива. Когда достигается элемент, который не является массивом, его значение добавляется к сумме.
// -----
// ⋙ ❍ В чем причина помещения всего содержимого исходного файла JavaScript в книгу функций? ✔
// Помещение всего содержимого исходного файла JavaScript в книгу функций (IIFE - Immediately Invoked Function Expression) имеет несколько причин:
// /Помещение всего содержимого исходного файла JavaScript в книгу функций (IIFE) помогает изолировать переменные и функции от глобальной области видимости, предотвращая конфликты имён, улучшая безопасность, обеспечивая контроль зависимостей и оптимизируя код.
// 1. Изоляция переменных: Помещение кода в IIFE позволяет изолировать переменные и функции от глобальной области видимости. Это предотвращает конфликты имён с другими скриптами и библиотеками.
// 2. Предотвращение конфликтов: Использование IIFE позволяет избежать возможных конфликтов с глобальными переменными и функциями, которые могут быть определены в других частях приложения.
// 3. Улучшение безопасности: Поскольку переменные и функции находятся внутри IIFE и не доступны извне, это может помочь защитить код от несанкционированного доступа и модификаций.
// 4. Контроль зависимостей: IIFE позволяет явно управлять порядком выполнения кода и зависимостями между модулями, что способствует более структурированному и предсказуемому поведению приложения.
// 5. Оптимизация и уменьшение объема кода: Помещение кода в IIFE может помочь оптимизировать его для выполнения и уменьшить его объем, например, путем минификации или удаления ненужных переменных и функций.
// В целом, использование IIFE является распространенной практикой в JavaScript разработке для создания модульной и безопасной структуры кода.
// -----
// ⋙ ❍ Перечислите специальные числовые значения ✔
// Вот несколько специальных числовых значений, которые могут использоваться в различных контекстах:
// 1. NaN (Not a Number): Представляет значение, которое не является числом/нечисловое. Обычно возникает при математических операциях, которые не могут быть выполнены или не имеют смысла.
// 2. Infinity (Бесконечность): Представляет положительную бесконечность. Обычно возникает при делении числа на ноль или при выполнении математических операций, которые приводят к бесконечному результату.
// 3. -Infinity (Отрицательная бесконечность): Представляет отрицательную бесконечность. Аналогично Infinity, но для отрицательных значений.
// 4. 0 (Ноль): Представляет значение нуля/Нулевое. Это специальное числовое значение, которое имеет свои уникальные математические свойства.
// 5. -0 (Отрицательный ноль): Ноль с отрицательным знаком. В большинстве случаев ведет себя так же, как обычный ноль, но есть некоторые математические операции, где он может иметь различное поведение.
// Эти специальные числовые значения часто используются в JavaScript и других языках программирования для обозначения определенных состояний или результатов математических операций.
// -----
// ⋙ ❍ Какое предназначение файла package-lock.json? ✔
// Файл `package-lock.json` используется в проектах Node.js для фиксации точных версий всех зависимостей проекта. Его основное назначение - обеспечить повторяемость установки зависимостей при разработке, тестировании и развертывании проекта.
// Вот основные задачи, которые выполняет `package-lock.json`:
// 1. Фиксация версий зависимостей: Файл содержит информацию о конкретных версиях каждого пакета, установленного в проекте. Это включает в себя версии основных пакетов, их зависимостей и подзависимостей.
// 2. Гарантированная повторяемость установки: `package-lock.json` гарантирует, что при установке зависимостей на разных машинах или в разные моменты времени будут установлены те же версии пакетов. Это помогает избежать неожиданных изменений в окружении разработки.
// 3. Ускорение установки зависимостей: Файл позволяет npm или yarn использовать кэш для ускорения процесса установки, так как они знают, какие версии пакетов уже установлены.
// 4. Решение проблем с зависимостями: `package-lock.json` помогает предотвратить конфликты версий и несовместимости пакетов, поскольку фиксирует точные версии, используемые в проекте.
// В целом, `package-lock.json` повышает стабильность и надежность управления зависимостями в проектах Node.js, делая процесс разработки более предсказуемым и устойчивым.
// -----
// ⋙ ❍ Что такое запросы между источниками и CDN? ✔
// Запросы между источниками (CORS) и CDN (Content Delivery Network) - это два различных концепта, связанных с веб-разработкой и доставкой контента в Интернете.
// /это механизм безопасности веб-браузера, который контролирует, как веб-страницы на одном домене получают доступ к ресурсам (например, изображениям, скриптам, стилям) на других доменах.
// 1. Запросы между источниками (CORS - Cross-Origin Resource Sharing): Это механизм, позволяющий веб-страницам запрашивать ресурсы с других доменов, чем тот, на котором расположена сама страница. CORS предотвращает проблемы безопасности, связанные с запросами к другим доменам, путем добавления заголовков в HTTP-запросы и ответы, которые разрешают или запрещают доступ к ресурсам с других источников.
// 2. CDN (Content Delivery Network): Это сеть серверов, распределенных по всему миру, которая предоставляет контент (такой как изображения, стили, скрипты) для веб-сайтов. CDN помогает ускорить загрузку контента для пользователей, размещая его на серверах, близких к местоположению пользователя. Это также помогает снизить нагрузку на сервер основного хостинга и улучшить производительность веб-сайта.
// Связь между этими концепциями может быть такова, что CDN может быть использован для доставки ресурсов, требуемых CORS. Например, если ваш веб-сайт находится на домене `example.com`, а ваши скрипты хранятся на CDN, расположенном на домене `cdn.examplecdn.com`, для успешного выполнения запросов между источниками браузер должен иметь правильные настройки CORS для разрешения доступа к ресурсам на CDN.
// /CDN (Content Delivery Network) - это сеть серверов, распределенных по всему миру, которая предоставляет контент для веб-сайтов, улучшая скорость и производительность загрузки.
// /Связь между ними заключается в том, что CDN может использоваться для хранения и доставки ресурсов (например, изображений, стилей, скриптов), и для успешной загрузки этих ресурсов на веб-странице через CDN может потребоваться правильная настройка CORS.
// --------------------------------------------------------------------------------------------
// [ПРАВИЛЬНЫЕ ОТВЕТЫ НА ВОПРОСЫ ВЫШЕ]:
// ---------------------
// ⋙ ❍ Преобразование типов ✔
// 5 + '2' // "52"
// 5 + '2' == '5' + '2' == '52'
// 5 - "2" // 3
// 5 - "2" == 5-2 == 3
// true + true // 2
// true + true == 1 + 1 == 2
// -----
// ⋙ ❍ Promise ✔
// Это достаточно современный подход написания асинхронного кода. Ранее использовался подход с использованием колбеков. При большой вложенности получался т.н. «ад обратных вызовов».
// При использовании промисов код выглядит читабельно и удобен для редактирования:
// const printSec = (number) => {
//   return new Promise((resolve, reject) => {
//    setTimeout(() => {
//         console.log(`${number} sec`)
//         resolve()
//       },
//       1000)
//   })
// }
// printSec(1)
//   .then(() => printSec(2))
//   .then(() => printSec(3))
// -----
// ⋙ ❍ Прототипное наследование ✔
// Каждый объект в JS имеет базовый объект – прототип. Если свойство не находится в исходном объекте, то поиск продолжается в его «родительском» объекте.
// Установить прототип объекта можно только во время создания объекта: если вы создаете новый объект с помощью новой Func(), свойство объекта [[Prototype]] будет установлено на объект, на который ссылается Func.prototype.
// -----
// ⋙ ❍ Цикл событий ✔
// Задачи будут добавляться в цикл событий, но они не вызовут ни переполнения стека, ни бесконечной очереди, которая затормозит весь сайт.
// Так как макротаски после выполнения пропускают один цикл для отрисовки контента и выполнения микротасков, в отличие от микротасков, которые выполняются все в очереди перед тем, как передать управление следующему пункту в цикле событий.
// function foo() {
//     return Promise.resolve(1).then(foo);
// }
// foo();
// Выполнение данного кода вызовет затормаживание интерфейса, т.к. при выполнении одного микротаска в очередь добавляется новый микротаск, который сразу же должен выполниться, без передачи управления другому пункту цикла событий.
// -----
// ⋙ ❍ Типы данных: ✔
// Чтобы узнать тип переменной JavaScript, мы можем использовать оператор typeof.
// String – представляет собой серию символов и записывается в кавычках. Строку можно представить в одинарных или двойных кавычках.
// Number – представляет собой число и может быть записано с десятичными знаками или без них.
// BigInt – используется для хранения чисел, превышающих ограничение типа данных Number. Он может хранить большие целые числа и представлен добавлением «n» к целочисленному литералу.
// Boolean – представляет собой логическую сущность и может иметь только два значения: истина или ложь. Логические значения обычно используются для условного тестирования.
// Undefined – когда переменная объявлена, но не назначена, она имеет значение undefined, и ее тип также не определен.
// Null – представляет несуществующее или недопустимое значение.
// Symbol – это новый тип данных, представленный в версии JavaScript для ES6. Он используется для хранения анонимного и уникального значения.
// Object – используется для хранения коллекции данных.Важно помнить, что любой тип данных, который не является примитивным типом данных, относится к типу объекта в javascript.
// Array – это не отдельный тип данных, на самом деле это Object. `typeof null` равен «object» и это нужно учитывать в проверках.typeof «John Doe» // Возвращает «string»
// typeof  3.14 // Возвращает "number"
// typeof  true // Возвращает "boolean"
// typeof  234567890123456789012345678901234567890 n // Возвращает bigint
// typeof  undefined // Возвращает undefined
// typeof  null // Возвращает "object"
// typeof Symbol ( 'symbol' ) // Возвращает символ
// ```
// Найти сумму элементов массива, если вложенность массива неизвестна, используя рекурсию
// function arraySum(arr) {
//     let sum = 0;
//     arr.map((item) => {
//         if (Array.isArray(item)) {
//             sum += arraySum(item);
//         } else {
//             sum += item;
//         }
//     });
//     return sum;
// }
// console.log(arraySum([[1, 2, [3, 4]], [9], [10, 12]]));
// Ваш подход к использованию рекурсии для нахождения суммы элементов массива вполне верен. Однако, в вашей функции есть несколько моментов, которые можно улучшить. Вот исправленная версия:
// ```javascript
// function arraySum(arr) {
//     let sum = 0;
//     arr.forEach((item) => {
//         if (Array.isArray(item)) {
//             sum += arraySum(item); // Рекурсивно вызываем arraySum для вложенного массива
//         } else {
//             sum += item; // Если элемент не массив, просто добавляем его к сумме
//         }
//     });
//     return sum;
// }
// console.log(arraySum([[1, 2, [3, 4]], [9], [10, 12]])); // Выведет 41
// ```
// Этот код рекурсивно перебирает все элементы массива, и если элемент является массивом, вызывает `arraySum` для этого массива. Когда достигается элемент, который не является массивом, его значение добавляется к сумме.
// -----
// ⋙ ❍ Причина помещения всего содержимого исходного файла JavaScript в книгу функций ✔
// Этот метод создает замыкание вокруг всего содержимого файла, что создает частное пространство имен и тем самым помогает избежать потенциальных конфликтов имен между различными модулями и библиотеками JavaScript.
// Еще одна особенность этого метода – легко создать псевдоним для глобальной переменной. Это часто используется в плагинах jQuery.
// -----
// ⋙ ❍ Специальные числовые значения ✔
// Infinity больше любого числа
// -Infinity меньше любого числа
// NaN представляет собой ошибку (не число)
// -----
// ⋙ ❍ Предназначение файла package-lock.json ✔
// package-lock.json автоматически создается для любых операций, когда npm изменяет дерево node_modules или package.json. Он описывает точное дерево, которое было сгенерировано, так что последующие установки могут генерировать идентичные деревья, независимо от промежуточных обновлений зависимостей.
// -----
// ⋙ ❍ Запросы между источниками и CDN ✔
// Если мы сделаем выборку с произвольного веб-сайта, это, вероятно, не удастся. Основная концепция здесь – триплет домен/порт/протокол.
// Запросы из разных источников, отправленные в другой домен (даже субдомен), протокол или порт требуют специальных заголовков с удаленной стороны. Эта политика называется «CORS»: совместное использование ресурсов между источниками.
// -----
// ⋙ ❍ CDN (сеть доставки контента) ✔
// это группа серверов, расположенных во многих местах. Эти серверы хранят дублированные копии данных, чтобы серверы могли выполнять запросы данных в зависимости от того, какие серверы находятся ближе всего к соответствующим конечным пользователям. CDN обеспечивают быстрое обслуживание и меньше подвержены влиянию высокого трафика.
// -----
// ⋙ ❍ Опишите, как бы вы реализовали примитивное слайд-шоу. ✔
// Реализация примитивного слайд-шоу может быть выполнена с использованием HTML, CSS и JavaScript. Вот шаг за шагом, как это можно сделать.
// Шаг 1: HTML Структура
// Сначала создадим базовую HTML структуру для слайд-шоу.
// ```html
// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>Simple Slideshow</title>
//     <link rel="stylesheet" href="styles.css">
// </head>
// <body>
//     <div class="slideshow-container">
//         <div class="slide fade">
//             <img src="image1.jpg" style="width:100%">
//         </div>
//         <div class="slide fade">
//             <img src="image2.jpg" style="width:100%">
//         </div>
//         <div class="slide fade">
//             <img src="image3.jpg" style="width:100%">
//         </div>

//         <!-- Navigation buttons -->
//         <a class="prev" onclick="plusSlides(-1)">&#10094;</a>
//         <a class="next" onclick="plusSlides(1)">&#10095;</a>
//     </div>
//     <br>
//     <!-- Dots navigation -->
//     <div style="text-align:center">
//         <span class="dot" onclick="currentSlide(1)"></span>
//         <span class="dot" onclick="currentSlide(2)"></span>
//         <span class="dot" onclick="currentSlide(3)"></span>
//     </div>
//     <script src="script.js"></script>
// </body>
// </html>
// ```
// Шаг 2: CSS для стилей
// Добавим стили для слайдов и навигационных элементов.
// ```css
// /* styles.css */
// body {
//     font-family: Arial, sans-serif;
//     margin: 0;
// }

// .slideshow-container {
//     position: relative;
//     max-width: 1000px;
//     margin: auto;
// }

// .slide {
//     display: none;
// }

// img {
//     vertical-align: middle;
//     width: 100%;
// }

// /* Navigation buttons */
// .prev, .next {
//     cursor: pointer;
//     position: absolute;
//     top: 50%;
//     width: auto;
//     padding: 16px;
//     margin-top: -22px;
//     color: white;
//     font-weight: bold;
//     font-size: 18px;
//     transition: 0.6s ease;
//     border-radius: 0 3px 3px 0;
//     user-select: none;
// }

// .next {
//     right: 0;
//     border-radius: 3px 0 0 3px;
// }

// .prev:hover, .next:hover {
//     background-color: rgba(0,0,0,0.8);
// }

// /* Dots navigation */
// .dot {
//     cursor: pointer;
//     height: 15px;
//     width: 15px;
//     margin: 0 2px;
//     background-color: #bbb;
//     border-radius: 50%;
//     display: inline-block;
//     transition: background-color 0.6s ease;
// }

// .active, .dot:hover {
//     background-color: #717171;
// }

// /* Fading animation */
// .fade {
//     animation-name: fade;
//     animation-duration: 1.5s;
// }

// @keyframes fade {
//     from {opacity: .4}
//     to {opacity: 1}
// }
// ```
// Шаг 3: JavaScript для функционала
// Теперь добавим JavaScript для управления слайдами.
// ```javascript
// // script.js
// let slideIndex = 1;
// showSlides(slideIndex);

// // Next/previous controls
// function plusSlides(n) {
//     showSlides(slideIndex += n);
// }

// // Thumbnail image controls
// function currentSlide(n) {
//     showSlides(slideIndex = n);
// }

// function showSlides(n) {
//     let i;
//     let slides = document.getElementsByClassName("slide");
//     let dots = document.getElementsByClassName("dot");
//     if (n > slides.length) {slideIndex = 1}
//     if (n < 1) {slideIndex = slides.length}
//     for (i = 0; i < slides.length; i++) {
//         slides[i].style.display = "none";
//     }
//     for (i = 0; i < dots.length; i++) {
//         dots[i].className = dots[i].className.replace(" active", "");
//     }
//     slides[slideIndex-1].style.display = "block";
//     dots[slideIndex-1].className += " active";
// }
// ```
// Объяснение
// 1. HTML:
// - Контейнер с классом `slideshow-container` содержит все слайды.
// - Каждый слайд представлен как `div` с классом `slide` и содержит изображение.
// - Добавлены навигационные кнопки (`prev` и `next`) для переключения слайдов.
// - Навигационные точки (`dot`) для перехода к определенному слайду.
// 2. CSS:
// - Стили для контейнера слайд-шоу, слайдов, изображений, кнопок навигации и точек.
// - Анимация для плавного перехода между слайдами.
// 3. JavaScript:
// - Управляет показом слайдов и навигационными элементами.
// - Функция `showSlides` скрывает все слайды и показывает текущий.
// - Функции `plusSlides` и `currentSlide` обновляют текущий индекс слайда и вызывают `showSlides` для отображения соответствующего слайда.
// ---
// ✐ На примере проектов:
// Пример 1: Реализация слайд-шоу для корпоративного сайта
// Ситуация: На корпоративном сайте клиента требуется создать слайд-шоу на главной странице для отображения ключевых продуктов компании.
// - "На одном из проектов для корпоративного сайта клиента я реализовал примитивное слайд-шоу с помощью HTML, CSS и JavaScript. Это слайд-шоу позволяло демонстрировать ключевые продукты компании с возможностью навигации между слайдами. Вот как я это сделал:
// 1. HTML Структура: Создал контейнер для слайдов и добавил изображения продуктов.
// 2. CSS Стилизация: Добавил стили для слайдов, кнопок навигации и точек индикатора.
// 3. JavaScript Логика: Написал скрипты для переключения слайдов по таймеру и по нажатию на кнопки.
// ```html
// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>Corporate Slideshow</title>
//     <link rel="stylesheet" href="styles.css">
// </head>
// <body>
//     <div class="slideshow-container">
//         <div class="slide fade">
//             <img src="product1.jpg" style="width:100%">
//         </div>
//         <div class="slide fade">
//             <img src="product2.jpg" style="width:100%">
//         </div>
//         <div class="slide fade">
//             <img src="product3.jpg" style="width:100%">
//         </div>
//         <a class="prev" onclick="plusSlides(-1)">&#10094;</a>
//         <a class="next" onclick="plusSlides(1)">&#10095;</a>
//     </div>
//     <br>
//     <div style="text-align:center">
//         <span class="dot" onclick="currentSlide(1)"></span>
//         <span class="dot" onclick="currentSlide(2)"></span>
//         <span class="dot" onclick="currentSlide(3)"></span>
//     </div>
//     <script src="script.js"></script>
// </body>
// </html>
// ```

// ```css
// /* styles.css */
// body {
//     font-family: Arial, sans-serif;
//     margin: 0;
// }

// .slideshow-container {
//     position: relative;
//     max-width: 1000px;
//     margin: auto;
// }

// .slide {
//     display: none;
// }

// img {
//     vertical-align: middle;
//     width: 100%;
// }

// .prev, .next {
//     cursor: pointer;
//     position: absolute;
//     top: 50%;
//     width: auto;
//     padding: 16px;
//     margin-top: -22px;
//     color: white;
//     font-weight: bold;
//     font-size: 18px;
//     transition: 0.6s ease;
//     border-radius: 0 3px 3px 0;
//     user-select: none;
// }

// .next {
//     right: 0;
//     border-radius: 3px 0 0 3px;
// }

// .prev:hover, .next:hover {
//     background-color: rgba(0,0,0,0.8);
// }

// .dot {
//     cursor: pointer;
//     height: 15px;
//     width: 15px;
//     margin: 0 2px;
//     background-color: #bbb;
//     border-radius: 50%;
//     display: inline-block;
//     transition: background-color 0.6s ease;
// }

// .active, .dot:hover {
//     background-color: #717171;
// }

// .fade {
//     animation-name: fade;
//     animation-duration: 1.5s;
// }

// @keyframes fade {
//     from {opacity: .4}
//     to {opacity: 1}
// }
// ```

// ```javascript
// // script.js
// let slideIndex = 1;
// showSlides(slideIndex);

// function plusSlides(n) {
//     showSlides(slideIndex += n);
// }

// function currentSlide(n) {
//     showSlides(slideIndex = n);
// }

// function showSlides(n) {
//     let i;
//     let slides = document.getElementsByClassName("slide");
//     let dots = document.getElementsByClassName("dot");
//     if (n > slides.length) {slideIndex = 1}
//     if (n < 1) {slideIndex = slides.length}
//     for (i = 0; i < slides.length; i++) {
//         slides[i].style.display = "none";
//     }
//     for (i = 0; i < dots.length; i++) {
//         dots[i].className = dots[i].className.replace(" active", "");
//     }
//     slides[slideIndex-1].style.display = "block";
//     dots[slideIndex-1].className += " active";
// }
// ```
// Эта реализация обеспечила плавное переключение между слайдами и возможность пользователям вручную переключаться между продуктами. Это улучшило пользовательский опыт и позволило клиенту эффективно демонстрировать свои продукты."
// Пример 2: Слайд-шоу для портфолио
// Ситуация: На личном сайте-резюме требуется создать слайд-шоу для демонстрации выполненных проектов.
// - "Для своего личного сайта-резюме я реализовал слайд-шоу для демонстрации проектов. Это слайд-шоу помогло посетителям быстро ознакомиться с моими работами. Вот как я это сделал:
// 1. HTML: Создал контейнер для слайдов и добавил изображения проектов.
// 2. CSS: Стили для слайдов, кнопок и индикаторов.
// 3. JavaScript: Скрипты для автоматического и ручного переключения слайдов.
// ```html
// <!DOCTYPE html>
// <html lang="en">
// <head>
//     <meta charset="UTF-8">
//     <meta name="viewport" content="width=device-width, initial-scale=1.0">
//     <title>Portfolio Slideshow</title>
//     <link rel="stylesheet" href="styles.css">
// </head>
// <body>
//     <div class="slideshow-container">
//         <div class="slide fade">
//             <img src="project1.jpg" style="width:100%">
//         </div>
//         <div class="slide fade">
//             <img src="project2.jpg" style="width:100%">
//         </div>
//         <div class="slide fade">
//             <img src="project3.jpg" style="width:100%">
//         </div>
//         <a class="prev" onclick="plusSlides(-1)">&#10094;</a>
//         <a class="next" onclick="plusSlides(1)">&#10095;</a>
//     </div>
//     <br>
//     <div style="text-align:center">
//         <span class="dot" onclick="currentSlide(1)"></span>
//         <span class="dot" onclick="currentSlide(2)"></span>
//         <span class="dot" onclick="currentSlide(3)"></span>
//     </div>
//     <script src="script.js"></script>
// </body>
// </html>
// ```

// ```css
// /* styles.css */
// body {
//     font-family: Arial, sans-serif;
//     margin: 0;
// }

// .slideshow-container {
//     position: relative;
//     max-width: 1000px;
//     margin: auto;
// }

// .slide {
//     display: none;
// }

// img {
//     vertical-align: middle;
//     width: 100%;
// }

// .prev, .next {
//     cursor: pointer;
//     position: absolute;
//     top: 50%;
//     width: auto;
//     padding: 16px;
//     margin-top: -22px;
//     color: white;
//     font-weight: bold;
//     font-size: 18px;
//     transition: 0.6s ease;
//     border-radius: 0 3px 3px 0;
//     user-select: none;
// }

// .next {
//     right: 0;
//     border-radius: 3px 0 0 3px;
// }

// .prev:hover, .next:hover {
//     background-color: rgba(0,0,0,0.8);
// }

// .dot {
//     cursor: pointer;
//     height: 15px;
//     width: 15px;
//     margin: 0 2px;
//     background-color: #bbb;
//     border-radius: 50%;
//     display: inline-block;
//     transition: background-color 0.6s ease;
// }

// .active, .dot:hover {
//     background-color: #717171;
// }

// .fade {
//     animation-name: fade;
//     animation-duration: 1.5s;
// }

// @keyframes fade {
//     from {opacity: .4}
//     to {opacity: 1}
// }
// ```

// ```javascript
// // script.js
// let slideIndex = 1;
// showSlides(slideIndex);

// function plusSlides(n) {
//     showSlides(slideIndex += n);
// }

// function currentSlide(n) {
//     showSlides(slideIndex = n);
// }

// function showSlides(n) {
//     let i;
//     let slides = document.getElementsByClassName("slide");
//     let dots = document.getElementsByClassName("dot");
//     if (n > slides.length) {slideIndex = 1}
//     if (n < 1) {slideIndex = slides.length}
//     for (i = 0; i < slides.length; i++) {
//         slides[i].style.display = "none";
//     }
//     for (i = 0; i < dots.length; i++) {
//         dots[i].className = dots[i].className
// -----
// ⋙ ❍ Если бы у вас была возможность освоить новую технологию в этом году, что бы это было? ✔
// Если бы у меня была возможность освоить новую технологию в этом году, я бы выбрал изучение Svelte и SvelteKit. Вот примеры, как можно обосновать этот выбор в различных ситуациях на работе фронтенд-разработчика.
// Пример 1: Инновации и Производительность
// Ситуация: На собрании команды обсуждаются перспективные технологии, которые могли бы повысить производительность разработки и улучшить производительность конечного продукта. Менеджер просит каждого члена команды предложить технологию для изучения.
// - "Если бы у меня была возможность освоить новую технологию в этом году, я бы выбрал Svelte и SvelteKit. Эти инструменты предлагают инновационный подход к разработке, отличающийся от традиционных фреймворков. Svelte компилирует код во время сборки, что приводит к меньшему размеру пакета и более высокой производительности. Это особенно важно для улучшения пользовательского опыта на мобильных устройствах с ограниченными ресурсами.
// Кроме того, SvelteKit предоставляет мощный инструментарий для создания полноценных приложений с поддержкой серверного рендеринга и статической генерации. Это поможет нам создать быстрые и SEO-дружественные веб-приложения."
// Пример 2: Улучшение Разработки Пользовательского Интерфейса
// Ситуация: Вы участвуете в планировании нового проекта и обсуждаете, какие технологии могут улучшить процесс разработки пользовательского интерфейса.
// - "Я бы выбрал освоение Svelte и SvelteKit в этом году, потому что они значительно упрощают создание сложных пользовательских интерфейсов. В отличие от React или Vue, Svelte устраняет необходимость в виртуальном DOM и напрямую обновляет реальный DOM, что делает код более читаемым и поддерживаемым.
// Svelte также имеет минималистичный и интуитивно понятный синтаксис, что ускоряет процесс разработки. Это поможет нам быстрее внедрять новые фичи и улучшать пользовательский интерфейс, сохраняя при этом высокую производительность."
// Пример 3: Вклад в Open Source
// Ситуация: На встрече с командой обсуждается возможность вклада в open source проекты для повышения видимости компании и профессионального роста сотрудников.
// - "Если бы я мог выбрать одну технологию для освоения в этом году, это были бы **Svelte** и **SvelteKit**. Оба проекта активно развиваются и имеют открытый исходный код, что дает отличную возможность внести свой вклад в open source сообщество. Участие в разработке и улучшении этих инструментов не только поможет нам улучшить свои навыки, но и повысит репутацию нашей компании в сообществе разработчиков."
// Пример 4: Преимущества для Клиентов
// Ситуация: Ваш клиент заинтересован в создании высокопроизводительного и современного веб-приложения. Вы предлагаете свои идеи по выбору технологий для проекта.
// - "Я рекомендую освоить Svelte и SvelteKit, поскольку они предоставляют значительные преимущества для разработки высокопроизводительных веб-приложений. Svelte компилирует компоненты во время сборки, что минимизирует нагрузку на клиентскую сторону и ускоряет время загрузки страниц. SvelteKit, в свою очередь, предлагает интегрированные решения для серверного рендеринга и статической генерации, что идеально подходит для SEO и улучшения скорости загрузки страниц.
// Эти технологии позволят нам создать быстрое, отзывчивое и современное веб-приложение, которое будет соответствовать высоким ожиданиям наших клиентов."
// Освоение Svelte и SvelteKit в этом году предложит множество преимуществ:
// - Производительность: Улучшение производительности за счет компиляции во время сборки и уменьшения размера пакета.
// - Простота и Удобство: Интуитивно понятный синтаксис и прямое обновление DOM делают разработку проще и быстрее.
// - Современные Возможности: Полная поддержка серверного рендеринга и статической генерации для создания SEO-дружественных и быстрых приложений.
// - Open Source: Возможность внесения вклада в активно развивающиеся open source проекты.
// Эти преимущества делают Svelte и SvelteKit отличным выбором для освоения в этом году, чтобы улучшить наши навыки и создать более эффективные и современные веб-приложения.
// ---
// ✐ Примеры ответов из коммерческой работы фронтенд-разработчика:
// Пример 1: Интеграция с современными библиотеками
// Ситуация: На встрече команды обсуждаются технологии, которые помогут улучшить текущий проект, и у каждого члена команды спрашивают, какую технологию они хотели бы освоить в этом году.
// - "Если бы у меня была возможность освоить новую технологию в этом году, я бы выбрал **Svelte** и **SvelteKit**. Эти инструменты предлагают современный и эффективный подход к разработке пользовательских интерфейсов. В отличие от традиционных фреймворков, Svelte компилирует компоненты во время сборки, что приводит к более производительному и легкому коду. На текущем проекте, где мы стремимся улучшить производительность и скорость загрузки страниц, это могло бы существенно повлиять на конечный результат."
// Пример 2: Улучшение пользовательского опыта
// Ситуация: Ваш менеджер хочет узнать, какие технологии могут помочь улучшить пользовательский опыт на сайте, и спрашивает вашу команду о возможностях изучения новых технологий.
// - "Я бы выбрал освоение Svelte и SvelteKit. Эти инструменты позволяют создавать более производительные и отзывчивые интерфейсы. Недавно я работал над проектом, где важен был быстрый отклик интерфейса, и Svelte идеально подходит для таких задач благодаря отсутствию виртуального DOM и прямому взаимодействию с реальным DOM. Это особенно полезно для создания интерактивных и сложных пользовательских интерфейсов."
// Пример 3: Оптимизация для мобильных устройств
// Ситуация: Ваш клиент хочет, чтобы веб-приложение работало плавно и быстро на мобильных устройствах. Вы предлагаете технологию для изучения, чтобы достичь этой цели.
// - "Если бы у меня была возможность освоить новую технологию, я бы выбрал **Svelte** и **SvelteKit**. Эти инструменты создают чрезвычайно легкие и быстрые приложения, что особенно важно для мобильных пользователей. На прошлых проектах мы столкнулись с проблемами производительности на мобильных устройствах, и использование Svelte могло бы значительно улучшить пользовательский опыт за счет уменьшения размера пакетов и быстрого рендеринга."
// Пример 4: Современный стек технологий
// Ситуация: Ваша команда рассматривает обновление стека технологий, чтобы соответствовать современным стандартам веб-разработки. Вам предлагают высказать свое мнение о возможных технологиях.
// - "Я бы выбрал освоение Svelte и SvelteKit, так как они представляют собой современный подход к разработке веб-приложений. Они предлагают встроенную поддержку серверного рендеринга, статической генерации и имеют минималистичный синтаксис, что упрощает разработку и поддержку кода. Это идеально вписывается в наше стремление использовать передовые технологии для создания высококачественных веб-приложений."
// Выбор Svelte и SvelteKit для освоения в этом году может принести множество преимуществ:
// 1. Производительность: Быстрая загрузка и рендеринг благодаря компиляции во время сборки.
// 2. Простота разработки: Интуитивно понятный синтаксис и отсутствие необходимости в виртуальном DOM.
// 3. Современные возможности: Встроенная поддержка серверного рендеринга и статической генерации.
// 4. Оптимизация для мобильных устройств: Легкие и быстрые приложения, подходящие для мобильных пользователей.
// Эти преимущества делают Svelte и SvelteKit отличным выбором для улучшения наших навыков и повышения качества создаваемых веб-приложений.
// -----
// ⋙ ❍ Объясните важность стандартов и комитетов по стандартам. ✔
// Важность стандартов и комитетов по стандартам:
// Пример 1: Совместимость и Интероперабельность
// Ситуация: Ваш менеджер спрашивает, почему так важно следовать веб-стандартам и участвовать в комитетах по стандартам.
// - "Следование веб-стандартам критически важно для обеспечения совместимости и интероперабельности нашего кода. Веб-стандарты, разработанные комитетами, такими как W3C (World Wide Web Consortium), гарантируют, что наши приложения будут работать корректно на всех браузерах и устройствах.
// Например, я недавно работал над проектом, где мы использовали новые HTML5 теги и CSS3 свойства. Благодаря стандартам W3C, мы могли быть уверены, что эти технологии поддерживаются во всех современных браузерах, что значительно уменьшило время на тестирование и исправление ошибок для разных платформ."
// Пример 2: Долговечность и Поддерживаемость Кода
// Ситуация: Ваш коллега сомневается, почему нам нужно строго следовать стандартам, когда можно использовать собственные решения для ускорения процесса разработки.
// - "Следование стандартам не только упрощает процесс разработки, но и значительно улучшает долговечность и поддерживаемость кода. В прошлом я работал над проектом, где предыдущие разработчики использовали нестандартные методы и проприетарные решения. Когда пришло время обновления или интеграции новых функций, это вызвало множество проблем, так как их подход не был совместим с современными стандартами.
// Использование стандартных технологий позволяет нам быть уверенными, что наш код будет легко поддерживаться в будущем, даже если проект передадут другим разработчикам."
// Пример 3: Доступность и Инклюзивность
// Ситуация: Ваша команда обсуждает, как улучшить доступность сайта для пользователей с ограниченными возможностями, и кто-то предлагает использовать нестандартные решения.
// - "Стандарты, такие как WCAG (Web Content Accessibility Guidelines), разработанные W3C, играют ключевую роль в обеспечении доступности и инклюзивности веб-сайтов. Я недавно работал над проектом, где важно было обеспечить доступность для всех пользователей. Следование стандартам WCAG помогло нам сделать сайт доступным для пользователей с ограниченными возможностями.
// Например, использование семантических HTML-тегов и ARIA-атрибутов обеспечило корректное взаимодействие сайта со скринридерами, что значительно улучшило пользовательский опыт для людей с ограниченным зрением."
// Пример 4: Обеспечение Безопасности
// Ситуация: Ваш клиент обеспокоен безопасностью веб-приложения и спрашивает, как стандарты могут помочь в этом.
// - "Следование веб-стандартам также важно для обеспечения безопасности нашего веб-приложения. Комитеты по стандартам, такие как OWASP (Open Web Application Security Project), разрабатывают руководства и рекомендации для защиты веб-приложений от различных угроз.
// На одном из прошлых проектов мы строго следовали рекомендациям OWASP, что помогло нам избежать распространенных уязвимостей, таких как XSS (Cross-Site Scripting) и CSRF (Cross-Site Request Forgery). Это значительно повысило уровень безопасности нашего приложения и доверие со стороны клиентов."
// - Совместимость и Интероперабельность: Следование стандартам обеспечивает работу кода на всех платформах и устройствах.
// - Долговечность и Поддерживаемость: Стандарты гарантируют, что код будет поддерживаемым и легко обновляемым в будущем.
// - Доступность и Инклюзивность: Стандарты помогают сделать веб-приложения доступными для всех пользователей, включая людей с ограниченными возможностями.
// - Обеспечение Безопасности: Стандарты предоставляют рекомендации для защиты веб-приложений от различных угроз.
// Следование веб-стандартам и участие в комитетах по стандартам обеспечивает создание качественных, долговечных и безопасных веб-приложений, что в конечном итоге повышает удовлетворенность пользователей и доверие клиентов.
// -----
// ⋙ ❍ Что такое FOUC (Flash Of Unstyled Content)? Как его избежать? ✔
// FOUC (Flash Of Unstyled Content) — это проблема, которая возникает, когда содержимое веб-страницы отображается без примененного CSS-стиля, а затем внезапно применяются стили, создавая мерцание. Это может произойти по разным причинам, но часто связано с задержками загрузки CSS-файлов.
// Примеры ответов из ситуаций на работе фронтенд-разработчика:
// Пример 1: Задержка загрузки CSS
// Ситуация: Ваш коллега замечает, что на сайте происходит мерцание не стилизованного контента и спрашивает, что такое FOUC и как вы собираетесь это исправить.
// - "FOUC (Flash Of Unstyled Content) происходит, когда содержимое страницы отображается до полной загрузки и применения CSS. Это создает неприятный визуальный эффект мерцания. Чтобы избежать этого, я решил внедрить несколько стратегий:
// 1. Inline Critical CSS: Внедрение критических стилей непосредственно в HTML для первоначальной загрузки страницы. Вот пример:
//     ```html
//     <style>
//       body {
//         font-family: Arial, sans-serif;
//         background-color: #f0f0f0;
//       }
//       /* Критические стили для быстрого отображения */
//     </style>
//     ```
// 2. Асинхронная загрузка CSS: Использование атрибута `rel="preload"` для предварительной загрузки CSS.
//     ```html
//     <link rel="preload" href="styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
//     <noscript><link rel="stylesheet" href="styles.css"></noscript>
//     ```
// Эти методы помогают минимизировать FOUC и улучшить восприятие страницы пользователями."
// Пример 2: Использование JavaScript для управления стилями
// Ситуация: Ваша команда разработчиков обсуждает способы уменьшения FOUC в новом проекте. Как бы вы объяснили свой подход?
// - "Для уменьшения FOUC я предлагаю использовать JavaScript для применения стилей только после их полной загрузки. Это гарантирует, что никакой контент не будет отображаться без стилей. Вот пример подхода, который я использовал ранее:
// 1. Добавление CSS через JavaScript:
//     ```javascript
//     const link = document.createElement('link');
//     link.rel = 'stylesheet';
//     link.href = 'styles.css';
//     document.head.appendChild(link);
//     link.onload = () => {
//       document.documentElement.classList.add('styles-loaded');
//     };
//     ```
// 2. Скрытие контента до загрузки стилей:
//     ```css
//     .styles-loaded body {
//       visibility: visible;
//     }

//     body {
//       visibility: hidden;
//     }
//     ```
// Этот метод гарантирует, что пользователи увидят только полностью стилизованный контент, избегая неприятного мерцания."
// Пример 3: Оптимизация загрузки шрифтов
// Ситуация: На вашем проекте шрифты загружаются медленно, что также приводит к FOUC. Как бы вы это решили?
// - "Загрузка шрифтов может быть причиной FOUC. Чтобы решить эту проблему, я использовал несколько стратегий оптимизации шрифтов:
// 1. Предварительная загрузка шрифтов:
//     ```html
//     <link rel="preload" href="fonts/font.woff2" as="font" type="font/woff2" crossorigin="anonymous">
//     ```
// 2. Использование `font-display`:
//     ```css
//     @font-face {
//       font-family: 'MyFont';
//       src: url('fonts/font.woff2') format('woff2');
//       font-display: swap;
//     }
//     ```
// С атрибутом `font-display: swap`, текст сначала отображается с запасным шрифтом, а затем автоматически обновляется на загруженный шрифт, предотвращая FOUC."
// FOUC — это проблема, возникающая при задержке загрузки CSS, приводящая к кратковременному отображению не стилизованного контента. Избежать FOUC можно разными способами:
// 1. Внедрение критических CSS стилей напрямую в HTML.
// 2. Асинхронная загрузка CSS с использованием атрибута `preload`.
// 3. Управление стилями через JavaScript.
// 4. Оптимизация загрузки шрифтов.
// Эти методы помогают обеспечить более гладкое и приятное восприятие сайта пользователями.
// -----
// ⋙ ❍ Объясните, что такое ARIA и скринридеры, а также как сделать сайт доступным. ✔
// Пример 1: Понимание ARIA
// Ситуация: Вы работаете над сложным веб-приложением с динамическим контентом и интерактивными элементами. Ваш руководитель спрашивает вас, что такое ARIA и как вы используете его в проекте.
// - "ARIA (Accessible Rich Internet Applications) — это набор атрибутов для HTML, которые помогают улучшить доступность веб-приложений. Например, у нас есть кнопки, которые показывают и скрывают разделы контента. Чтобы скринридеры могли правильно интерпретировать эти действия, я использую ARIA-атрибуты. Вот пример кода:
// ```html
// <button aria-expanded="false" aria-controls="content1" id="toggleButton">Toggle Content</button>
// <div id="content1" role="region" aria-labelledby="toggleButton">
//   <p>Here is the content that can be toggled.</p>
// </div>
// ```
// Когда пользователь нажимает кнопку, я обновляю `aria-expanded` с `false` на `true`, чтобы скринридеры могли сообщить пользователю, что контент теперь виден. Это помогает пользователям с ограниченными возможностями лучше понимать, что происходит на странице."
// Пример 2: Использование скринридеров
// Ситуация: Ваш коллега спрашивает вас, как скринридеры помогают пользователям с ограниченными возможностями и что вы сделали для улучшения взаимодействия с вашим сайтом.
// - "Скринридеры — это программы, которые преобразуют текст и элементы интерфейса на экране в звуковой вывод или вывод на брайль, помогая незрячим или слабовидящим пользователям. Для нашего проекта я убедился, что все изображения имеют описательные `alt`-атрибуты. Например:
// ```html
// <img src="profile.jpg" alt="Фото профиля пользователя Иван Иванов">
// ```
// Кроме того, я использовал семантические теги HTML5, такие как `<nav>`, `<main>`, `<section>`, чтобы структура страницы была понятна скринридерам. Это помогает пользователям легко навигировать по нашему сайту."
// Пример 3: Фокусируемые элементы и управление клавиатурой
// Ситуация: Вам поручено обеспечить доступность навигации на сайте с помощью клавиатуры. Ваш менеджер спрашивает, что вы сделали для этого.
// - "Я убедился, что все интерактивные элементы могут быть доступны с клавиатуры. Например, все ссылки и кнопки получают фокус при навигации с помощью клавиши Tab. Вот пример кода:
// ```html
// <a href="#content" class="skip-link">Skip to main content</a>
// ```
// Кроме того, я добавил фокусируемые стили, чтобы было видно, какой элемент в данный момент активен. Пример CSS:
// ```css
// a:focus, button:focus {
//   outline: 2px solid #00f;
// }
// ```
// Это делает сайт более доступным для пользователей, которые не могут использовать мышь."
// Пример 4: Цветовая доступность
// Ситуация: Ваш дизайнер предложил новую цветовую схему, и вы должны убедиться, что она соответствует стандартам доступности.
// - "Я проверил контрастность цвета текста и фона с помощью инструмента проверки контраста, чтобы убедиться, что они соответствуют стандартам WCAG. Например, текст на кнопках должен быть достаточно контрастным:
// ```css
// button {
//   background-color: #0000ff; /* Синий фон */
//   color: #ffffff; /* Белый текст */
// }
// ```
// Эти цвета имеют достаточный контраст, чтобы текст был легко читаемым для пользователей с нарушениями зрения. Я также убедился, что информация не передается только через цвет, добавив текстовые метки и иконки, когда это необходимо."
// - ARIA атрибуты: Используйте для предоставления дополнительной информации и контекста интерактивных элементов.
// - Скринридеры: Программное обеспечение, которое преобразует текст и элементы интерфейса в звуковой вывод или вывод на брайль.
// - Доступность сайта: Используйте семантический HTML, обеспечьте фокусируемость элементов, управляйте цветовой доступностью и тестируйте сайт с помощью инструментов для проверки доступности.
// Применение этих практик помогает сделать веб-сайты доступными для всех пользователей, включая тех, кто использует вспомогательные технологии.
// ---
// /ARIA (Accessible Rich Internet Applications) — это набор атрибутов для HTML и JavaScript, который предназначен для улучшения доступности веб-приложений для пользователей с ограниченными возможностями. Основные цели ARIA:
// 1. Доступность элементов интерфейса: ARIA позволяет добавлять дополнительную информацию и контекст для элементов интерфейса, делая их более понятными для пользователей, использующих вспомогательные технологии.
// 2. Улучшение взаимодействия: ARIA обеспечивает поддержку интерактивности и динамических изменений на странице, что помогает пользователям получать более полезную информацию и управлять приложением.
// Скринридеры — это программное обеспечение, которое помогает незрячим или слабовидящим пользователям взаимодействовать с компьютером и веб-страницами, преобразуя текст и другой контент на экране в звуковой вывод или вывод в брайль. Они читают содержимое страницы вслух и обеспечивают навигацию по элементам интерфейса.
// Как сделать сайт доступным?
// 1. Использование семантического HTML:
// - Используйте теги HTML соответствующим образом: `<nav>`, `<main>`, `<section>`, `<article>`, `<aside>`, `<footer>`, чтобы скринридеры могли правильно интерпретировать структуру страницы.
// 2. Использование ARIA атрибутов:
// - Добавляйте ARIA-атрибуты к элементам, чтобы предоставить дополнительную информацию о их роли, состоянии или свойствах. Примеры:
// - `role="navigation"` для навигационного меню.
// - `aria-label="Основное меню"` для явного описания элемента.
// 3. Правильное использование alt-атрибутов для изображений**:
// - Для изображений добавляйте `alt`-атрибуты с описанием изображения или пустыми атрибутами (`alt=""`), если изображение декоративное.
// 4. Фокусируемые элементы:
// - Обеспечьте, чтобы все интерактивные элементы (кнопки, ссылки) могли получить фокус клавиатуры, и управление ими было интуитивно понятным и предсказуемым.
// 5. Управление клавиатурой:
// - Проверьте, что сайт можно полностью управлять с клавиатуры без использования мыши. Это включает навигацию по ссылкам и интерактивным элементам с помощью клавиш Tab и Enter.
// 6. Цветовая доступность:
// - Используйте достаточно контрастные цвета для текста и фона, чтобы обеспечить читаемость для пользователей с ограниченным зрением.
// 7. Тестирование доступности:
// - Проводите регулярное тестирование доступности с помощью инструментов, таких как Lighthouse, Axe, или встроенных инструментов разработчика в браузере.
// Сделать сайт доступным — значит обеспечить равный доступ к информации и функционалу для всех пользователей, независимо от их способностей или технологий, которые они используют для взаимодействия с интернетом.
// -----
// ⋙ ❍ Какие преимущества и недостатки у CSS и JavaScript анимаций? ✔
// Анимации в веб-разработке могут быть выполнены с помощью CSS или JavaScript, и каждый из этих методов имеет свои преимущества и недостатки. Рассмотрим их подробнее.
// CSS Анимации
// Преимущества:
// 1. Производительность:
// - CSS-анимации часто более производительны, так как браузеры могут оптимизировать их выполнение и использовать аппаратное ускорение.
// 2. Простота использования:
// - Синтаксис CSS-анимаций и переходов прост и понятен. Они легко применяются через свойства `transition` и `animation`.
// 3. Меньше кода:
// - Для большинства простых анимаций требуется меньше кода, что делает CSS-анимации более лаконичными.
// 4. Автоматическая оптимизация:
// - Браузеры автоматически оптимизируют CSS-анимации, что помогает избежать проблем с производительностью.
// Недостатки:
// 1. Ограниченные возможности:
// - CSS-анимации не так гибки, как анимации на JavaScript. Некоторые сложные анимации или анимации, требующие сложной логики, труднее реализовать.
// 2. Отсутствие динамики:
// - Сложно анимировать динамически изменяющиеся свойства или взаимодействовать с пользовательскими действиями во время анимации.
// JavaScript Анимации
// Преимущества:
// 1. Гибкость:
// - JavaScript предлагает полный контроль над анимацией, позволяя изменять любые свойства в реальном времени и реагировать на пользовательские события.
// 2. Сложные и динамические анимации:
// - Легко создавать сложные последовательные анимации, взаимодействовать с DOM-элементами и изменять анимацию на лету.
// 3. Библиотеки:
// - Существуют мощные библиотеки, такие как GSAP или anime.js, которые упрощают создание сложных анимаций и предоставляют дополнительные возможности.
// Недостатки:
// 1. Производительность:
// - JavaScript-анимации могут потреблять больше ресурсов, так как они часто требуют перерисовки и перерасчета стилей, особенно если они не оптимизированы.
// 2. Больше кода:
// - Для создания анимаций с помощью JavaScript обычно требуется больше кода, что может усложнить поддержку и сопровождение.
// 3. Требовательность к навыкам:
// - Для создания качественных JavaScript-анимаций требуется больше знаний и опыта в программировании.
// Примеры
// CSS Анимация
// ```css
// .box {
//   width: 100px;
//   height: 100px;
//   background-color: red;
//   transition: transform 2s;
// }

// .box:hover {
//   transform: rotate(45deg);
// }
// ```
// JavaScript Анимация
// ```javascript
// const box = document.querySelector('.box');

// box.addEventListener('mouseover', () => {
//   box.style.transition = 'transform 2s';
//   box.style.transform = 'rotate(45deg)';
// });

// box.addEventListener('mouseout', () => {
//   box.style.transition = 'transform 2s';
//   box.style.transform = 'rotate(0deg)';
// });
// ```
// - CSS-анимации хороши для простых, декларативных анимаций, которые требуют минимальных ресурсов и легко применяются.
// - JavaScript-анимации предоставляют большую гибкость и контроль, подходя для сложных сценариев, но могут быть более требовательными к производительности и требуют больше кода.
// Оба подхода имеют свои применения, и часто лучший выбор зависит от конкретных требований проекта и опыта разработчика.
// Кратко:
// /Преимущества:
// 1. Быстро и просто:
// - CSS-анимации легко применять и писать. Они требуют меньше кода и проще в использовании. Например, чтобы сделать кнопку плавно изменяющей цвет при наведении, достаточно нескольких строк CSS.
// 2. Производительность:
// - Браузеры могут оптимизировать CSS-анимации и использовать аппаратное ускорение, что делает их более плавными и менее требовательными к ресурсам.
// 3. Стабильность:
// - CSS-анимации чаще всего работают без проблем и багов, так как они встроены в браузеры.
// Недостатки:
// 1. Ограниченные возможности:
// - Сложные и динамические анимации, которые зависят от пользовательских действий или других переменных, трудно сделать с помощью только CSS. Например, анимации, которые должны изменяться в зависимости от времени дня, требуют JavaScript.
// 2. Меньше контроля:
// - В CSS у вас меньше контроля над анимацией по сравнению с JavaScript. Если нужно что-то более сложное, чем простое изменение стиля, это может стать проблемой.
// JavaScript Анимации
// Преимущества:
// 1. Гибкость и мощность:
// - JavaScript позволяет делать очень сложные и динамические анимации. Вы можете анимировать любые свойства и реагировать на действия пользователя в реальном времени. Например, игра с множеством анимаций и взаимодействий.
// 2. Легкость интеграции с логикой приложения:
// - JavaScript-анимации легко связать с логикой вашего приложения. Вы можете изменять анимации на лету, основываясь на данных или пользовательских действиях.
// 3. Библиотеки и инструменты:
// - Существуют мощные библиотеки, такие как GSAP или anime.js, которые упрощают создание сложных анимаций и предлагают много готовых решений.
// Недостатки:
// 1. Больше кода и сложность:
// - Для создания анимаций с помощью JavaScript обычно нужно больше кода и знаний. Это может быть сложнее для начинающих.
// 2. Производительность:
// - JavaScript-анимации могут быть более ресурсоемкими, особенно если не оптимизированы. Они могут замедлять страницу, если не использовать их осторожно.
// Примеры
// CSS Анимация (простая)
// ```css
// .button {
//   background-color: blue;
//   transition: background-color 0.5s;
// }

// .button:hover {
//   background-color: red;
// }
// ```
// JavaScript Анимация (сложнее, но гибче)
// ```javascript
// const button = document.querySelector('.button');

// button.addEventListener('mouseover', () => {
//   button.style.transition = 'background-color 0.5s';
//   button.style.backgroundColor = 'red';
// });

// button.addEventListener('mouseout', () => {
//   button.style.transition = 'background-color 0.5s';
//   button.style.backgroundColor = 'blue';
// });
// ```
// - CSS-анимации идеальны для простых, декларативных анимаций. Они быстры и эффективны, но имеют ограничения в гибкости.
// - JavaScript-анимации дают полный контроль и позволяют создавать сложные и интерактивные эффекты. Они требуют больше усилий и могут быть более ресурсоемкими.
// Выбор между CSS и JavaScript для анимации зависит от задачи: для простых эффектов лучше использовать CSS, а для сложных взаимодействий — JavaScript.
// ---
// ✐ Примеры ситуаций на работе фронтенд-разработчика, где проявляются преимущества и недостатки CSS и JavaScript анимаций:
// Пример 1: Простое наведение курсора
// Ситуация: Вам нужно сделать так, чтобы кнопка меняла цвет при наведении курсора.
// CSS-анимации:
// ```css
// .button {
//   background-color: blue;
//   transition: background-color 0.5s;
// }

// .button:hover {
//   background-color: red;
// }
// ```
// Преимущества:
// - Простота: Очень легко реализовать. Всего несколько строк кода.
// - Производительность: Браузеры хорошо оптимизируют такие анимации.
// Недостатки:
// - Ограниченные возможности: Только простое изменение цвета, без сложных эффектов.
// Пример 2: Сложная анимация при прокрутке
// Ситуация: Вы хотите анимировать элементы на странице по мере прокрутки вниз.
// JavaScript-анимации:
// ```javascript
// window.addEventListener('scroll', () => {
//   const elements = document.querySelectorAll('.animate-on-scroll');
//   elements.forEach(element => {
//     if (element.getBoundingClientRect().top < window.innerHeight) {
//       element.style.opacity = 1;
//       element.style.transform = 'translateY(0)';
//     }
//   });
// });
// ```
// Преимущества:
// - Гибкость: Можно анимировать любые свойства и учитывать положение элемента на странице.
// - Мощность: Легко адаптировать анимации под разные сценарии и условия.
// Недостатки:
// - Больше кода: Нужно написать больше кода для реализации.
// - Производительность: При большом количестве анимируемых элементов могут возникнуть проблемы с производительностью.
// Пример 3: Анимация загрузки данных
// Ситуация: Вы хотите показать анимацию загрузки данных с сервера.
// CSS-анимации:
// ```css
// .loader {
//   border: 16px solid #f3f3f3;
//   border-radius: 50%;
//   border-top: 16px solid blue;
//   width: 120px;
//   height: 120px;
//   animation: spin 2s linear infinite;
// }

// @keyframes spin {
//   0% { transform: rotate(0deg); }
//   100% { transform: rotate(360deg); }
// }
// ```
// Преимущества:
// - Простота: Легко реализовать анимацию вращения с помощью CSS.
// - Производительность: Браузеры оптимизируют выполнение анимаций.
// Недостатки:
// - Ограниченные возможности: Нельзя легко изменять анимацию в зависимости от состояния загрузки.
// JavaScript-анимации:
// ```javascript
// const loader = document.querySelector('.loader');

// function startLoading() {
//   loader.style.display = 'block';
// }

// function stopLoading() {
//   loader.style.display = 'none';
// }

// // Пример использования
// startLoading();
// // Имитация загрузки данных
// setTimeout(stopLoading, 2000);
// ```
// Преимущества:
// - Гибкость: Легко контролировать анимацию и ее состояние через JavaScript.
// - Интерактивность: Можно изменять анимацию в зависимости от различных условий и состояний.
// Недостатки:
// - Больше кода: Требуется больше кода и логики для управления анимацией.
// - Производительность: Нужно следить за оптимизацией, чтобы анимации не влияли на производительность.
// CSS-анимации:
// - Преимущества: Простота, высокая производительность, легкость в написании для простых эффектов.
// - Недостатки: Ограниченные возможности, сложно делать сложные и динамичные анимации.
// JavaScript-анимации:
// - Преимущества: Гибкость, мощность, возможность создавать сложные и интерактивные анимации.
// - Недостатки: Требуется больше кода, могут быть проблемы с производительностью, если не оптимизировать.
// Выбор между CSS и JavaScript-анимациями зависит от конкретной задачи. Для простых эффектов лучше использовать CSS, а для сложных взаимодействий и динамичных анимаций — JavaScript.
// -----
// ⋙ ❍ Что означает CORS и какую проблему решает? ✔
// CORS (Cross-Origin Resource Sharing) — это механизм безопасности, внедренный в веб-браузеры, который позволяет контролировать, какие ресурсы могут быть запрашиваемы из другого домена (происхождения), отличного от того, с которого был загружен основной ресурс. Основная задача CORS — защита веб-приложений от определенного рода атак, известных как "cross-origin" атаки, таких как CSRF (Cross-Site Request Forgery).
// Проблема, которую решает CORS
// Веб-браузеры по умолчанию следуют политике одного источника (same-origin policy). Эта политика ограничивает взаимодействие между ресурсами, загруженными с разных источников (доменов), чтобы защитить данные пользователя от вредоносного доступа. Например, если ваше приложение загружено с `https://example.com`, оно не может делать запросы к `https://anotherdomain.com` без разрешения.
// Проблема заключается в том, что многие современные веб-приложения часто нуждаются в доступе к ресурсам, расположенным на других доменах, например, API-сервисы, изображения, шрифты и т.д. Если бы браузеры строго придерживались политики одного источника, это сделало бы разработку таких приложений крайне затруднительной.
// Как работает CORS
// CORS позволяет серверу сообщить браузеру, что он разрешает доступ к своим ресурсам из другого источника. Это делается с помощью специальных заголовков HTTP, добавленных к ответу сервера.
// Основные заголовки CORS
// 1. Access-Control-Allow-Origin
//    - Этот заголовок определяет, какие источники могут иметь доступ к ресурсу. Значение `*` означает, что доступ разрешен для всех источников.
//    - Пример: `Access-Control-Allow-Origin: https://example.com`
// 2. Access-Control-Allow-Methods
//    - Определяет, какие HTTP-методы (GET, POST, PUT и т.д.) разрешены при доступе к ресурсу.
//    - Пример: `Access-Control-Allow-Methods: GET, POST, PUT`
// 3. Access-Control-Allow-Headers
//    - Определяет, какие заголовки могут быть использованы при запросе к ресурсу.
//    - Пример: `Access-Control-Allow-Headers: Content-Type, Authorization`
// 4. Access-Control-Allow-Credentials
//    - Определяет, разрешено ли включать учетные данные (например, куки) в запрос.
//    - Пример: `Access-Control-Allow-Credentials: true`
// 5. Access-Control-Expose-Headers
//    - Определяет, какие заголовки могут быть доступны скрипту на стороне клиента.
//    - Пример: `Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision`
// Пример CORS в действии
// Предположим, у вас есть веб-приложение на `https://example.com`, которое должно делать запросы к API на `https://api.anotherdomain.com`. Для разрешения такого взаимодействия сервер `https://api.anotherdomain.com` должен настроить соответствующие заголовки.
// Пример настройки заголовков в Node.js с использованием Express:
// ```javascript
// app.use((req, res, next) => {
//   res.header("Access-Control-Allow-Origin", "https://example.com");
//   res.header("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE");
//   res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
//   next();
// });
// ```
// CORS является важным механизмом безопасности в веб-разработке, позволяющим безопасно разрешать запросы между разными источниками. Он позволяет серверам контролировать, какие источники могут запрашивать их ресурсы, и таким образом предотвращает потенциальные атаки и несанкционированный доступ к данным.
// /Что такое CORS?
// CORS (Cross-Origin Resource Sharing) — это механизм, который позволяет веб-сайтам запрашивать ресурсы с другого домена, а не только с того, с которого был загружен сам веб-сайт. По умолчанию браузеры блокируют такие "кросс-доменные" запросы по соображениям безопасности.
// Какую проблему решает CORS?
// Проблема:
// Когда вы создаете веб-сайт, он обычно загружает данные с того же домена (например, `https://example.com`). Но иногда вашему сайту нужно получить данные с другого домена (например, `https://api.anotherdomain.com`). Например, ваш сайт может отправлять запросы к внешнему API для получения данных о погоде, новостей или любых других данных.
// Браузеры по умолчанию блокируют такие запросы из соображений безопасности. Это называется "политика одного источника" (Same-Origin Policy). Она предотвращает атаки, при которых вредоносный сайт мог бы попытаться получить данные с другого сайта от имени пользователя.
// Решение:
// CORS позволяет серверу, к которому вы хотите обратиться, сообщить браузеру, что этот сервер разрешает кросс-доменные запросы. Это делается с помощью специальных заголовков, которые сервер отправляет в ответе.
// Как это работает?
// 1. Запрос с вашего сайта:
//    Ваш сайт на `https://example.com` отправляет запрос к API на `https://api.anotherdomain.com`.
// 2. Ответ сервера:
//    Сервер `https://api.anotherdomain.com` отвечает и включает в свой ответ заголовок, который говорит браузеру: "Я разрешаю этому сайту (`https://example.com`) запрашивать мои ресурсы."
//    Например, такой заголовок:
//    ```http
//    Access-Control-Allow-Origin: https://example.com
//    ```
// 3. Браузер проверяет:
//    Если браузер видит этот заголовок в ответе сервера, он позволяет вашему сайту получить доступ к данным. Если нет — браузер блокирует ответ и ваш сайт не может использовать эти данные.
// Пример в действии
// Представьте, у вас есть веб-приложение на `https://example.com`, и вам нужно получить данные от API на `https://api.anotherdomain.com`. Сервер `https://api.anotherdomain.com` должен быть настроен таким образом, чтобы разрешать запросы от `https://example.com`.
// В коде вашего сервера (например, на Node.js с использованием Express) это может выглядеть так:
// ```javascript
// app.use((req, res, next) => {
//   res.header("Access-Control-Allow-Origin", "https://example.com");
//   res.header("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE");
//   res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
//   next();
// });
// ```
// CORS — это механизм, который позволяет вашему сайту безопасно запрашивать ресурсы с другого домена. Он решает проблему безопасности, позволяя серверам контролировать, какие сайты могут обращаться к их ресурсам, и предотвращает злоупотребления со стороны вредоносных сайтов.
// /Что такое CORS?
// CORS (Cross-Origin Resource Sharing) — это механизм в браузерах, который позволяет веб-сайтам запрашивать данные с других сайтов.
// Какую проблему решает CORS?
// Проблема:
// Представьте, что вы находитесь на сайте, который загружен с адреса `https://mysite.com`. Этот сайт может захотеть получить данные с другого сайта, например, `https://api.othersite.com`. Однако, из соображений безопасности, браузеры по умолчанию блокируют такие запросы, чтобы защитить вас от потенциальных угроз, таких как кража данных.
// Решение:
// CORS позволяет сайту `https://api.othersite.com` сказать вашему браузеру: "Этому сайту (`https://mysite.com`) можно запрашивать мои данные". Это делается через специальные сообщения, называемые заголовками, которые сервер отправляет вместе с ответом на запрос.
// Пример:
// 1. Вы находитесь на сайте `https://mysite.com`.
// 2. Этот сайт хочет получить данные с `https://api.othersite.com`.
// 3. Когда сайт `https://mysite.com` отправляет запрос к `https://api.othersite.com`, сервер `https://api.othersite.com` отвечает с заголовком, который говорит: "Да, `https://mysite.com`, ты можешь получить мои данные".
// 4. Ваш браузер видит этот заголовок и разрешает сайту `https://mysite.com` использовать данные от `https://api.othersite.com`.
// Как это выглядит на практике:
// Сервер `https://api.othersite.com` добавляет в свой ответ заголовок, например:
// ```http
// Access-Control-Allow-Origin: https://mysite.com
// ```
// Этот заголовок говорит браузеру, что сайту `https://mysite.com` можно доверять и можно передавать данные.
// Почему это важно:
// CORS помогает защитить вас от вредоносных сайтов, которые могли бы пытаться получить ваши данные без разрешения. Одновременно он позволяет легитимным сайтам взаимодействовать и обмениваться данными, создавая более полезные и интегрированные веб-приложения.
// CORS — это как паспортный контроль для веб-сайтов. Он разрешает или запрещает доступ к данным с других сайтов, помогая обеспечить вашу безопасность в интернете.
// -----
// ⋙ ❍ Что происходит в следующем коде:? ✔
// var foo = 'bim'
// var getFoo = function () { return foo }
// foo = 'boum'
// console.log(getFoo());
// Ответ — ‘boum’, поскольку на третьей строке значение foo изменяется на ‘boum’, и функция getFoo вернет переменную foo в своей области видимости.
// -----
// ⋙ ❍ Измените данный массив, добавив ‘Ten’ в его конец? ✔
// var arr = [‘One’, ‘Two’, ‘Three’, ‘Four’, ‘Five’, ‘Six’, ‘Seven’, ‘Eight’, ‘Nine’];
// Это можно сделать несколькими способами, используя метод .push.
// arr.push('Ten');
// или можно было использовать свойство “length” в качестве индекса.
// arr[arr.length] = 'Ten';
// -----
// ⋙ ❍ Измените этот массив, добавьте в его начало слово “Zero”? ✔
// var arr = [‘One’, ‘Two’, ‘Three’, ‘Four’, ‘Five’, ‘Six’, ‘Seven’, ‘Eight’, ‘Nine’];
// Мы можем сделать это по-разному, используя .unshift.
// arr.unshift('Zero');
// или, используя метод splice…
// arr.splice(0, 0, 'Zero');
// -----
// ⋙ ❍ Что происходит здесь? ✔
// function test() {
//   console.log(a);
//   console.log(foo());
//   var a = 1;
//   function foo() {
//     return 2;
//   }
// }
// test();
// Ответом является неопределенность и 2.
// Переменная “a” неопределена на первой строке, что выводится в консоль. Функция “foo()” поднимается в начало функции и может быть выполнена на второй строке.
// -----
// ⋙ ❍ Что здесь происходит? ✔
// var fullname = 'John Doe';
// var obj = {
//   fullname: 'Colin Ihrig',
//   prop: {
//     fullname: 'Aurelio De Rosa',
//     getFullname: function() {
//       return this.fullname;
//     }
//   }
// };
// console.log(obj.prop.getFullname());
// var test = obj.prop.getFullname;
// console.log(test());
// Ответом являются Aurelio De Rosa и John Doe.
// Вызов функции obj.prop.getFullname() вернет свойство fullname объекта obj.prop, потому что область видимости функции находится внутри obj.prop.
// Однако присвоение функции переменной test изменяет ее область выполнения на область переменной test, которая в данном случае является объектом window.
// -----
// ⋙ ❍ Что здесь происходит? ✔
// for (var i = 0; i < 4; i++) {
//   setTimeout(() => console.log(i), 0)
// }
// Код выводит 4, 4, 4, 4 в консоль, потому что setTimeout выполняется после for-цикла, который устанавливает значение i равным 4 на последнем цикле.
// Этот код создает цикл, который выполняет функцию `console.log(i)` с задержкой в 0 миллисекунд после каждой итерации. Но что происходит на самом деле?
// 1. Цикл начинается с переменной `i` установленной в 0.
// 2. `setTimeout(() => console.log(i), 0)` создает таймер, который запланирует выполнение функции `console.log(i)` после 0 миллисекунд.
// 3. Поскольку задержка равна 0, функция не выполняется немедленно, а добавляется в очередь событий.
// 4. Цикл продолжается, `i` увеличивается на 1.
// 5. Опять же, `setTimeout(() => console.log(i), 0)` создает таймер для выполнения `console.log(i)` снова после 0 миллисекунд, и так происходит для каждой итерации цикла.
// После завершения цикла `i` будет равно 4, так как это условие прекращения цикла. Теперь, когда все функции `console.log(i)` добавлены в очередь событий, они начнут выполняться. Но к этому моменту значение `i` уже станет 4. Поэтому при выполнении функций `console.log(i)` на самом деле будет выведено 4 раза число 4.
// -----
// ⋙ ❍ Как сделать, чтобы он выводил вместо этого 0, 1, 2, 3? ✔
// Просто замените var i на let i. Это изменит, как i обрабатывается внутри скобок {} области видимости for-цикла. Это новая функция ES6, блочная область видимости.
// for (let i = 0; i < 4; i++) {
//   setTimeout((function () { console.log(this.i) }).bind({i}), 0)
// }
// Результат приведенного выше цикла for аналогичен следующему, где мы используем безымянную функцию, чтобы контролировать область видимости переменной i, передав ее в безымянную функцию и тем самым имитируя блочную область видимости.
// for (var i = 0; i < 4; i++) {
//   (function (i) {
//     setTimeout(function () { console.log(i) }, 0)
//   })(i);
// }
// Или же вы можете использовать метод bind, чтобы привязать объект с i к области функции.
// for (var i = 0; i < 4; i++) {
//   setTimeout((function () { console.log(this.i) }).bind({i}), 0)
// }
// -----
// ⋙ ❍ Подсчёт элементов в массив? ✔
// ✎ Оно простое и должно определить, как они справятся со следующими вызовами. Это должно занять не более 5–10 минут, но для кого-то это может превратиться в 20–30 минут.
// ✎ Вы можете подумать, что живые кодовые вызовы — хорошая идея, но я использую их с определенной осторожностью, потому что даже лучшие из нас могут нервничать.
// ✎ Помните, что программирование обычно выполняется без чьего-либо присмотра.
// Ищите через массив ‘arr’, используя элементы из ‘inputs’. Напишите функцию, которая возвращает объект, содержащий количество каждого из элементов из ‘inputs’.
// var arr = [“A”, “B”, “C”, “D”, “S”, “W”, “A”, “B”, “B”, “C”, “G”];
// var inputs = [“C”, “B”];
// function search(arr, inputs) {
//   ...
// }
// let res = search(arr, inputs);
// console.log(res.B);
// console.log(res.C);
// -----
// ⋙ ❍ Ищем шаблон внутри массива? ✔
// ✎ Это упражнение очень похоже на первое, но вместо поиска каждого элемента мы ищем весь шаблон. В данном случае шаблоном является B & C, который повторяется внутри массива дважды.
// var arr = [“A”, “B”, “C”, “D”, “S”, “W”, “A”, “B”, “B”, “C”, “G”];
// var pattern = [“B”, “C”];
// function search(arr, pattern) {
//   ...
// }
// let count = search(arr, inputs);
// console.log(count);
// Для поиска шаблона внутри массива можно использовать следующий подход на JavaScript:
// ```javascript
// var arr = ["A", "B", "C", "D", "S", "W", "A", "B", "B", "C", "G"];
// var pattern = ["B", "C"];

// function search(arr, pattern) {
//   var count = 0;
//   for (var i = 0; i < arr.length - pattern.length + 1; i++) {
//     var match = true;
//     for (var j = 0; j < pattern.length; j++) {
//       if (arr[i + j] !== pattern[j]) {
//         match = false;
//         break;
//       }
//     }
//     if (match) {
//       count++;
//     }
//   }
//   return count;
// }

// let count = search(arr, pattern);
// console.log(count); // Выводит 2
// ```
// Этот код проходит по массиву `arr`, начиная с каждого элемента, и сравнивает его с шаблоном. Если найденное соответствие совпадает с шаблоном, счетчик увеличивается. В конце возвращается количество найденных шаблонов.
// -----
// ⋙ ❍ Преобразование строки элементов в массив? ✔
// Преобразование строки элементов в массив можно сделать с помощью метода разделения строки на подстроки по определенному разделителю. В большинстве языков программирования для этого используется встроенная функция или метод. Например, вот как это можно сделать на примере JavaScript:
// ```javascript
// let str = "apple,banana,orange";
// let arr = str.split(","); // Разделение строки по запятой
// console.log(arr); // ["apple", "banana", "orange"]
// ```
// В этом примере `split(",")` разбивает строку `str` на подстроки, используя запятую в качестве разделителя, и возвращает массив строк.
// На других языках программирования алгоритм будет похожим, хотя синтаксис может отличаться. Вот примеры на Python и Java:
// Python:
// ```python
// str = "apple,banana,orange"
// arr = str.split(",") # Разделение строки по запятой
// print(arr) # ['apple', 'banana', 'orange']
// ```
// Java:
// ```java
// String str = "apple,banana,orange";
// String[] arr = str.split(","); // Разделение строки по запятой
// System.out.println(Arrays.toString(arr)); // [apple, banana, orange]
// ```
// Каждый элемент строки между запятыми становится отдельным элементом в результирующем массиве.
// Преобразование строки элементов в массив:
// JavaScript: `str.split(",")`
// Python: `str.split(",")`
// Java: `str.split(",")`
// -----
// ⋙ ❍ Напишите функцию, которая преобразует любую из этих строк в массив? ✔
// const temp1 = 'One,Two,Three,Four,Five,Six,Seven,Eight,Nine';
// const temp2 = 'Two, One,Four, Three, Six, Five, Seven, Nine, Eight';
// Результат должен быть.
// [1, 2, 3, 4, 5, 6, 7, 8, 9]
// [2, 1, 4, 3, 6, 5, 7, 9, 8]
// ✎ Это упражнение немного затруднительно, потому что им нужно понять, что для преобразования слов в числа необходимо использовать словарь или операторы условия/выбора.
// Вот функция на JavaScript, которая преобразует строки в массивы:
// ```javascript
// const temp1 = 'One,Two,Three,Four,Five,Six,Seven,Eight,Nine';
// const temp2 = 'Two, One,Four, Three, Six, Five, Seven, Nine, Eight';

// function stringToArray(str) {
//   // Словарь для соответствия чисел словам
//   const dict = {
//     'One': 1,
//     'Two': 2,
//     'Three': 3,
//     'Four': 4,
//     'Five': 5,
//     'Six': 6,
//     'Seven': 7,
//     'Eight': 8,
//     'Nine': 9
//   };

//   // Разбиваем строку на массив слов
//   const words = str.split(',');

//   // Преобразуем каждое слово в числовое значение, используя словарь
//   const result = words.map(word => dict[word.trim()]);

//   return result;
// }
// console.log(stringToArray(temp1)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
// console.log(stringToArray(temp2)); // [2, 1, 4, 3, 6, 5, 7, 9, 8]
// ```
// Эта функция использует словарь `dict`, чтобы соответствовать словам числа от 1 до 9. Затем она разбивает строку на массив слов, преобразует каждое слово в числовое значение с помощью словаря и возвращает массив чисел.
// -----
// ⋙ ❍ Реализуйте следующий метод, который повторяет строку несколько раз? ✔
// ✎ Если бы они упомянули прототипное наследование, то не было бы никаких проблем с реализацией пользовательского метода прототипа.
// console.log(‘hello’.repeatify(3));
// Для добавления метода `repeatify` к прототипу строк на JavaScript можно использовать следующий код:
// ```javascript
// String.prototype.repeatify = function(n) {
//   return Array(n + 1).join(this);
// };
// console.log('hello'.repeatify(3)); // Выводит "hellohellohello"
// ```
// Этот код расширяет прототип `String`, добавляя метод `repeatify`, который принимает число `n` и повторяет текущую строку `n` раз. Внутри метода используется `Array(n + 1).join(this)`, чтобы создать новую строку, повторяя текущую строку `n` раз.
// -----
// ⋙ ❍ Реализация специального метода reverse? ✔
// Надо добавить метод ‘customReverse’ в объект Array, который бы переворачивал порядок элементов в массиве.
// console.log([0,1,2,3,4,5].customReverse());
// Для добавления метода `customReverse` к объекту `Array` на JavaScript можно использовать следующий код:
// ```javascript
// Array.prototype.customReverse = function() {
//   return this.slice().reverse();
// };
// console.log([0, 1, 2, 3, 4, 5].customReverse()); // Выводит [5, 4, 3, 2, 1, 0]
// ```
// Этот код расширяет прототип `Array`, добавляя метод `customReverse`, который использует `slice()` для создания копии массива и `reverse()` для изменения порядка элементов в копии. Таким образом, исходный массив остается неизменным, а метод `customReverse` возвращает перевернутую копию.
// -----
// ⋙ ❍ Создайте функцию array_sum, которая суммирует все числа в многомерной структуре массива? ✔
// array_sum([1,2,[3,4,[5]]])
// Вы можете реализовать функцию `array_sum`, используя рекурсивный подход для обхода всех элементов многомерного массива и суммирования чисел. Вот пример на JavaScript:
// ```javascript
// function array_sum(arr) {
//   let sum = 0;

//   // Рекурсивная функция для обхода элементов массива
//   function sumArray(arr) {
//     for (let i = 0; i < arr.length; i++) {
//       // Если текущий элемент массива - это массив, вызываем sumArray рекурсивно
//       if (Array.isArray(arr[i])) {
//         sumArray(arr[i]);
//       } else {
//         // Если элемент массива - число, добавляем его к сумме
//         sum += arr[i];
//       }
//     }
//   }

//   // Начинаем обход массива
//   sumArray(arr);

//   return sum;
// }
// console.log(array_sum([1, 2, [3, 4, [5]]])); // Выводит 15 (1 + 2 + 3 + 4 + 5)
// ```
// Этот код пройдет по всем элементам массива, проверяя, является ли текущий элемент массивом или числом. Если это массив, функция вызывает саму себя для этого вложенного массива. Если это число, оно добавляется к общей сумме.
// -----
// ⋙ ❍ Реализуйте метод, который вычисляет среднюю длину всех пакетов в структуре данных? ✔
// var packages = {
//   UPS: { length: 120, weight: 44 },
//   FedeX: { length: 135, weight: 130 },
//   USPS: { length: 150 }
// }
// function calculateAvgLength(packages) {
//   ...
// }
// console.log(calculateAvgLength(packages));
// Вы можете реализовать функцию `calculateAvgLength`, которая вычисляет среднюю длину всех пакетов в данной структуре данных. Вот пример на JavaScript:
// ```javascript
// var packages = {
//   UPS: { length: 120, weight: 44 },
//   FedEx: { length: 135, weight: 130 },
//   USPS: { length: 150 }
// };

// function calculateAvgLength(packages) {
//   let totalLength = 0;
//   let count = 0;

//   // Проходим по каждому пакету в структуре данных
//   for (let key in packages) {
//     if (packages.hasOwnProperty(key) && packages[key].length !== undefined) {
//       totalLength += packages[key].length;
//       count++;
//     }
//   }

//   // Вычисляем среднюю длину
//   const avgLength = count !== 0 ? totalLength / count : 0;

//   return avgLength;
// }

// console.log(calculateAvgLength(packages)); // Выводит 135 (средняя длина пакетов)
// ```
// Этот код проходит через все пакеты в объекте `packages`, суммирует их длины и подсчитывает общее количество пакетов. Затем он вычисляет среднее значение длины и возвращает его.
// -----
// ⋙ ❍ Реализуйте метод, который сортирует данную строку в другую? ✔
// let str = “Addy 2 Daddy 3 WoW 9 Modern 4 Architecture 87”;
// Должно быть отсортировано на:
// "acdehinortuyADMW234789"
// ✎ Кандидат должен выводить, что делать в рамках заданной процедуры, исходя из входных данных и ожидаемого результата.
// Чтобы реализовать метод, который сортирует данную строку в другую, вы можете использовать следующий код на JavaScript:
// ```javascript
// let str = "Addy 2 Daddy 3 WoW 9 Modern 4 Architecture 87";

// function sortString(str) {
//   // Удаляем пробелы из строки
//   let cleanedStr = str.replace(/\s/g, '');

//   // Отсортируем символы строки в алфавитном порядке
//   let sortedStr = cleanedStr.split('').sort().join('');

//   // Удаляем все не-цифровые символы из строки
//   let digitsOnly = sortedStr.replace(/\D/g, '');

//   return digitsOnly + sortedStr.replace(/\d/g, '');
// }
// console.log(sortString(str)); // Выводит "acdehinortuyADMW234789"
// ```
// Этот код удаляет пробелы из исходной строки, затем сортирует символы строки в алфавитном порядке. После этого он удаляет все не-цифровые символы из отсортированной строки и объединяет их в нужном порядке.
// -----
// ⋙ ❍ Прошу их создать класс, который преобразует JSON в XML и XML в JSON. Я даю им следующую структуру класса и прошу их заполнить ее? ✔
// class Transformer
// {
// public convertXMLtoJSON();
// public convertJSONtoXML();
// }
// convertXMLtoJSON — Программа преобразует любой XML-документ в структуру JSON, которую они реализуют самостоятельно.
// convertJSONtoXML — Преобразует JSON, сгенерированный функцией convertXMLtoJSON, обратно в документ XML.
// Пример реализации класса `Transformer`, который преобразует JSON в XML и XML в JSON на JavaScript:
// ```javascript
// class Transformer {
//   convertXMLtoJSON(xmlString) {
//     let xmlDoc = new DOMParser().parseFromString(xmlString, 'text/xml');
//     let json = this.xmlToJSON(xmlDoc);
//     return json;
//   }

//   convertJSONtoXML(jsonObject) {
//     let xmlString = this.jsonToXML(jsonObject);
//     return xmlString;
//   }

//   xmlToJSON(xmlNode) {
//     let obj = {};

//     if (xmlNode.nodeType === Node.ELEMENT_NODE) {
//       if (xmlNode.attributes.length > 0) {
//         obj['@attributes'] = {};
//         for (let i = 0; i < xmlNode.attributes.length; i++) {
//           let attribute = xmlNode.attributes.item(i);
//           obj['@attributes'][attribute.nodeName] = attribute.nodeValue;
//         }
//       }
//     } else if (xmlNode.nodeType === Node.TEXT_NODE) {
//       return xmlNode.nodeValue.trim();
//     }

//     if (xmlNode.hasChildNodes()) {
//       for (let i = 0; i < xmlNode.childNodes.length; i++) {
//         let item = xmlNode.childNodes.item(i);
//         let nodeName = item.nodeName;
//         if (nodeName === '#text') {
//           continue;
//         }
//         if (obj[nodeName] === undefined) {
//           obj[nodeName] = this.xmlToJSON(item);
//         } else {
//           if (obj[nodeName].push === undefined) {
//             let old = obj[nodeName];
//             obj[nodeName] = [];
//             obj[nodeName].push(old);
//           }
//           obj[nodeName].push(this.xmlToJSON(item));
//         }
//       }
//     }

//     return obj;
//   }

//   jsonToXML(obj) {
//     let xml = '';

//     for (let prop in obj) {
//       if (!obj.hasOwnProperty(prop)) {
//         continue;
//       }
//       if (prop === '@attributes') {
//         for (let attr in obj[prop]) {
//           if (obj[prop].hasOwnProperty(attr)) {
//             xml += ` ${attr}="${obj[prop][attr]}"`;
//           }
//         }
//       } else if (Array.isArray(obj[prop])) {
//         obj[prop].forEach((item) => {
//           xml += `<${prop}>${this.jsonToXML(item)}</${prop}>`;
//         });
//       } else if (typeof obj[prop] === 'object') {
//         xml += `<${prop}${this.jsonToXML(obj[prop])}></${prop}>`;
//       } else {
//         xml += `<${prop}>${obj[prop]}</${prop}>`;
//       }
//     }

//     return xml;
//   }
// }
// Пример использования:
// // let transformer = new Transformer();

// Преобразование XML в JSON
// // let xmlString = '<root><person name="John"><age>30</age></person></root>';
// let jsonObject = transformer.convertXMLtoJSON(xmlString);
// console.log(jsonObject);

// Преобразование JSON в XML
// let json = {
//   root: {
//     person: {
//       '@attributes': {
//         name: 'John'
//       },
//       age: '30'
//     }
//   }
// };
// let xmlString2 = transformer.convertJSONtoXML(json);
// console.log(xmlString2);
// ```
// Этот класс принимает XML-строку и JSON-объект в методах `convertXMLtoJSON` и `convertJSONtoXML` соответственно и возвращает преобразованный JSON-объект или XML-строку.
// -----
// ⋙ ❍ Как сделать так, чтобы выводило цифры по порядку? ✔
// Чтобы вывести цифры по порядку, вы можете использовать самовызывающуюся функцию или использовать замыкание для сохранения значения переменной `i` на каждой итерации цикла. Вот пример, как это можно сделать:
// ```javascript
// for (var i = 0; i < 10; i++) {
//   (function(index) {
//     setTimeout(function () {
//       console.log(index);
//     }, 0);
//   })(i);
// }
// ```
// В этом примере мы создаем самовызывающуюся функцию, которая получает значение переменной `i` как аргумент и сохраняет его в переменной `index`. Это позволяет каждой функции обратного вызова `setTimeout` использовать правильное значение `index`, сохраненное в замыкании. Таким образом, цифры будут выводиться по порядку от 0 до 9.
// -----
// ⋙ ❍ Напишите функцию принимающую строку с именем файла и возвращающую расширение (фрагмент после последней точки)? ✔
// Вы можете написать функцию, которая найдет расширение файла, используя методы строки JavaScript. Вот пример:
// ```javascript
// function getFileExtension(filename) {
//   // Находим последнее вхождение точки в строке
//   let lastDotIndex = filename.lastIndexOf('.');
//   // Если точка найдена и она не является последним символом в строке
//   if (lastDotIndex !== -1 && lastDotIndex < filename.length - 1) {
//     // Возвращаем подстроку после последней точки
//     return filename.substring(lastDotIndex + 1);
//   } else {
//     // Если точка не найдена или является последним символом, возвращаем пустую строку
//     return '';
//   }
// }
// // Пример использования
// console.log(getFileExtension('document.txt')); // Выведет: "txt"
// console.log(getFileExtension('image.jpg')); // Выведет: "jpg"
// console.log(getFileExtension('script.js.map')); // Выведет: "map"
// console.log(getFileExtension('file')); // Выведет: ""
// ```
// Эта функция использует метод `lastIndexOf()` для поиска последнего вхождения точки в имени файла и метод `substring()` для получения подстроки после последней точки. Если точка не найдена или является последним символом в строке, функция вернет пустую строку.
// -----
// ⋙ ❍ У вас есть строка “abcd”, и вам поручено написать функцию, которая переворачивает ее на “dcba”. Как бы вы это сделали? Подробно объясните? ✔︎
// Многие вспоминают метод .reverse у массивов.
// s.split('').reverse().join('');
// Однако некоторые могут использовать цикл for и метод charAt для разворота строки.
// function reverse(s) {
//   var o = [];
//   for (var i = 0, len = s.length; i <= len; i++)
//     o.push(s.charAt(len - i));
//   return o.join('');
// }
// -----
// ⋙ ❍ Что вернет выражение +new Date()? Чем отличается от Date.now()? ✔
// Ответ в том, что +new Date(); создаст экземпляр объекта Date и благодаря + переведет его в числовой формат. Во втором случае вызовется статический метод конструктора, который является более приоритетным, т.к. во-первых он не требует создания экземпляра, а во-вторых является более понятным.
// Правильно, выражение `+new Date()` создаст экземпляр объекта `Date` и затем преобразует его в числовой формат, представляющий количество миллисекунд, прошедших с начала эпохи Unix. Этот подход используется для быстрого получения текущего времени в миллисекундах.
// В то время как `Date.now()` является статическим методом объекта `Date`, который возвращает текущее время в миллисекундах, также представляющее количество миллисекунд, прошедших с начала эпохи Unix. Этот метод не требует создания экземпляра объекта `Date`, что делает его более эффективным и читаемым в некоторых случаях.
// -----
// ⋙ ❍ Напишите регулярное выражение для проверки строк соответствующих формату даты dd.mm.yyyy? ✔
// Каков будет результат выполнения следующего кода:
// for (var i = 0; i < 10; i++) {
//   setTimeout(function () {
//     console.log(i);
//   }, 0);
// }
// Регулярное выражение для проверки строк соответствующих формату даты `dd.mm.yyyy` будет выглядеть так:
// ```regex
// /^\d{2}\.\d{2}\.\d{4}$/
// ```
// Это регулярное выражение соответствует строке, которая начинается с двух цифр (`\d{2}`), затем точка, затем две цифры, точка, и четыре цифры в конце (`\d{4}`).
// Относительно кода, который вы предоставили, результат выполнения будет таким:
// ```plaintext
// 10
// 10
// 10
// 10
// 10
// 10
// 10
// 10
// 10
// 10
// ```
// Это происходит из-за того, что переменная `i` используется в замыкании функции обратного вызова внутри `setTimeout`. Когда функция обратного вызова выполняется позже, она использует последнее значение `i`, которое стало равным 10 после завершения цикла.
// -----
// ⋙ ❍ Как поменять контекст функции. Частичное применение функции? ✔
// В JavaScript вы можете изменить контекст функции с помощью методов `call()`, `apply()` и `bind()`. Частичное применение функции обычно осуществляется с помощью метода `bind()`.
// Изменение контекста функции:
// 1. call(): Метод `call()` вызывает функцию с указанным контекстом и аргументами.
// ```javascript
// function greet() {
//   console.log('Hello, ' + this.name);
// }

// var person = { name: 'John' };
// greet.call(person); // Выведет: "Hello, John"
// ```
// 2. apply(): Метод `apply()` вызывает функцию с указанным контекстом и массивом аргументов.
// ```javascript
// function greet(message) {
//   console.log(message + ', ' + this.name);
// }

// var person = { name: 'John' };
// greet.apply(person, ['Hello']); // Выведет: "Hello, John"
// ```
// Частичное применение функции:
// Метод `bind()` создает новую функцию, связывая указанный контекст с функцией. Возвращаемая функция также может иметь некоторые параметры, которые будут переданы при вызове.
// ```javascript
// function greet(message) {
//   console.log(message + ', ' + this.name);
// }

// var person = { name: 'John' };
// var greetJohn = greet.bind(person, 'Hello');
// greetJohn(); // Выведет: "Hello, John"
// ```
// В этом примере `greet.bind(person, 'Hello')` создает новую функцию `greetJohn`, которая будет вызывать `greet` с контекстом `person` и аргументом `'Hello'`. При вызове `greetJohn()` будет выведено `"Hello, John"`.
// Таким образом, частичное применение функции с помощью метода `bind()` позволяет задать некоторые параметры функции заранее, оставив другие параметры для передачи при вызове.
// -----
// ⋙ ❍ Как создать приватную переменную в JavaScript, используя ‘let’ или замыкание? ✔
// Замыкание может возвращать ссылку на функцию, которая позволяет нам получить доступ к приватному пространству.
// let getX = (function () {
//   let x = 100;
//   return function () {
//         return x;
//      }
// })();
// console.log("x: " + getX());
// Переменная, созданная с помощью ‘let’, привязана к своим скобкам.
// let getX;
// let x = 500;
// {
//     let x = 100;
//     getX = function () {
//         return x;
//     }
// }
// console.log("x1: " + getX());
// getX = function () {
//     return x;
// }
// console.log("x2: " + getX());
// -----
// ⋙ ❍ Чем отличается:? ✔
// var something = function
// &
// function something();
// Функция something() поднимается в начале, когда скрипт интерпретируется. В то время как переменная var something = function становится доступной для использования после соответствующего оператора.
// ---------------------------------------------------------------------------------------------
// [ПРАКТИЧЕСКИЕ РЕАЛЬНЫЕ ЗАДАНИЯ(lifeCoding)]:
// ---------------------
// ⋙ ❍ Расскажите, какие есть способы копирования простого объекта типа obj = {a: 1, b: 2, c: 3}? ✔
// 1. Присваивание объекта:
// Простейший способ - это просто присвоить объект другой переменной. Это создаст ссылку на существующий объект, а не его копию.
// ```javascript
// const original = {a: 1, b: 2, c: 3};
// const copy = original; // Это создает ссылку на тот же самый объект, а не его копию
// ```
// 2. Object.assign():
// Метод `Object.assign()` используется для копирования значений всех перечисляемых свойств из одного или нескольких исходных объектов в целевой объект.
// ```javascript
// const original = {a: 1, b: 2, c: 3};
// const copy = Object.assign({}, original);
// ```
// 3. Spread оператор (...) (ES6):
// Оператор распространения (spread operator) позволяет раскрыть элементы массива или объекта.
// ```javascript
// const original = {a: 1, b: 2, c: 3};
// const copy = {...original};
// ```
// 4. JSON.parse() и JSON.stringify():
// Другой способ - использовать `JSON.stringify()` для преобразования объекта в строку JSON, а затем `JSON.parse()` для преобразования обратно в объект.
// ```javascript
// const original = {a: 1, b: 2, c: 3};
// const copy = JSON.parse(JSON.stringify(original));
// ```
// Все эти методы копируют объект `{a: 1, b: 2, c: 3}`, но у каждого из них есть свои особенности. Например, присваивание объекта и `Object.assign()` создают поверхностную копию, тогда как распространение объекта и использование `JSON.stringify()` и `JSON.parse()` создают глубокую копию.
// -----
// ⋙ ❍ Напишите deep clone для объекта? ✔
// Вот пример реализации глубокого клонирования объекта в JavaScript:
// ```javascript
// function deepClone(obj) {
//   if (obj === null || typeof obj !== 'object') {
//     return obj; // Возвращаем простые типы данных и null как есть
//   }

//   let clone;

//   // Обрабатываем массивы
//   if (Array.isArray(obj)) {
//     clone = [];
//     for (let i = 0; i < obj.length; i++) {
//       clone[i] = deepClone(obj[i]);
//     }
//     return clone;
//   }

//   // Обрабатываем объекты
//   clone = {};
//   for (let key in obj) {
//     if (obj.hasOwnProperty(key)) {
//       clone[key] = deepClone(obj[key]);
//     }
//   }
//   return clone;
// }

// // Пример использования:
// const original = {
//   name: 'John',
//   age: 30,
//   address: {
//     city: 'New York',
//     country: 'USA'
//   },
//   hobbies: ['reading', 'running']
// };

// const cloned = deepClone(original);
// console.log(cloned);
// ```
// Этот код рекурсивно обходит объект и его свойства, создавая копии каждого вложенного объекта и массива. Таким образом, функция `deepClone()` создает глубокую копию исходного объекта.
// -----
// ⋙ ❍ Назовите различные способы, как поменять местами значения двух переменных? ✔
// Есть несколько способов поменять местами значения двух переменных в JavaScript.
// 1. С использованием временной переменной:
// ```javascript
// let a = 5;
// let b = 10;

// let temp = a;
// a = b;
// b = temp;

// console.log(a, b); // 10, 5
// ```
// 2. С помощью деструктуризации массива:
// ```javascript
// let a = 5;
// let b = 10;

// [b, a] = [a, b];

// console.log(a, b); // 10, 5
// ```
// 3. С помощью арифметических операций (подходит только для числовых значений):
// ```javascript
// let a = 5;
// let b = 10;

// a = a + b;
// b = a - b;
// a = a - b;

// console.log(a, b); // 10, 5
// ```
// 4. С использованием оператора XOR (исключающее ИЛИ) для логического обмена (подходит только для числовых значений):
// ```javascript
// let a = 5;
// let b = 10;

// a = a ^ b;
// b = a ^ b;
// a = a ^ b;

// console.log(a, b); // 10, 5
// ```
// Все эти способы достигают одного и того же результата: значения переменных `a` и `b` меняются местами. Выбор конкретного метода может зависеть от контекста и типов данных, с которыми вы работаете.
// -----
// ⋙ ❍ Менеджер попросил в задаче поменять статусы с «active, inactive» на «active, removed», но в коде фигурируют только цифры и непонятно, какой статус соответствует какой цифре. Как помочь будущим программистам не лезть в документацию по коду (Вопрос ставят на конкретном примере с кодом)? ✔
// Чтобы помочь будущим программистам легко понять, какая цифра соответствует какому статусу, вы можете использовать объект или Map для создания соответствия между цифрами и статусами. Вот пример, как это можно сделать:
// ```javascript
// const statusMap = {
//   1: 'active',
//   0: 'removed'
// };

// // Пример использования:
// const status = 1;
// console.log(statusMap[status]); // 'active'
// ```
// В этом примере `statusMap` - это объект, который сопоставляет цифры со строковыми статусами. Таким образом, если программист видит число в коде, он может легко определить, какому статусу оно соответствует, обратившись к `statusMap`. Это делает код более читаемым и понятным без необходимости обращаться к документации.
// -----
// ⋙ ❍ Нужно сделать минипроект — список пользователей с формой создания/редактирования пользователя:? ✔
// - Для хранения пользователей используйте Firebase (это бесплатно).
// - Для стилизации используйте Bootstrap.
// - Минимальный набор полей пользователя:
// - имя;
// - фамилия;
// - электронная почта;
// - телефон (в формате +380 (XX) XXX-XX-XX)
// - дата рождения;
// - будет плюсом добавление аватара и возможность crop-картинки.
// - Список пользователей должен иметь возможность фильтрации и пагинацию.
// - Проект должен содержать README-файл с шагами для запуска.
// -----
// ⋙ ❍ Реализуйте асинхронный метод filter для Array (должны работать await)? ✔
// Вот пример реализации асинхронного метода `filterAsync()` для массива, который позволяет использовать `await`:
// ```javascript
// Array.prototype.filterAsync = async function(predicate) {
//   const results = await Promise.all(this.map(async (element, index, array) => {
//     const result = await predicate(element, index, array);
//     return { element, result };
//   }));
//   return results.filter(({ result }) => result).map(({ element }) => element);
// };

// // Пример использования:
// const arr = [1, 2, 3, 4, 5];

// async function isEven(value) {
//   return value % 2 === 0;
// }

// (async () => {
//   const filtered = await arr.filterAsync(isEven);
//   console.log(filtered); // [2, 4]
// })();
// ```
// В этой реализации метод `filterAsync()` принимает асинхронный предикат (`predicate`), который возвращает промис с булевым значением. Он применяет предикат к каждому элементу массива с помощью метода `map()`, а затем собирает результаты с помощью `Promise.all()`. После этого он фильтрует результаты и возвращает массив отфильтрованных элементов, для которых предикат возвращает `true`.
// -----
// ⋙ ❍ Реализуйте функцию reduce с помощью рекурсии? ✔
// Вот пример реализации функции `reduce()` с использованием рекурсии:
// ```javascript
// function reduce(arr, callback, initialValue) {
//   // Проверка наличия начального значения
//   if (initialValue !== undefined) {
//     return reduceHelper(arr, callback, initialValue, 0);
//   } else {
//     if (arr.length === 0) {
//       throw new TypeError('Reduce of empty array with no initial value');
//     }
//     return reduceHelper(arr.slice(1), callback, arr[0], 1);
//   }
// }

// function reduceHelper(arr, callback, accumulator, index) {
//   // Базовый случай: если индекс достиг длины массива, возвращаем аккумулятор
//   if (index === arr.length) {
//     return accumulator;
//   }
//   // Рекурсивный случай: применяем функцию callback к текущему элементу и результату предыдущего вызова
//   const newAccumulator = callback(accumulator, arr[index], index, arr);
//   // Рекурсивный вызов с обновленными значениями
//   return reduceHelper(arr, callback, newAccumulator, index + 1);
// }

// // Пример использования:
// const arr = [1, 2, 3, 4, 5];
// const sum = reduce(arr, (acc, curr) => acc + curr, 0);
// console.log(sum); // 15
// ```
// Эта реализация `reduce()` работает как стандартный метод `reduce()`. Она принимает массив, функцию обратного вызова и (опционально) начальное значение аккумулятора. Рекурсивная функция `reduceHelper()` обходит массив, применяя функцию обратного вызова к каждому элементу и обновляя аккумулятор на каждом шаге.
// -----
// ⋙ ❍ Как можно было бы сделать toggle-компонент, как в iPhone, без использования JS? ✔
// Вы можете реализовать toggle-компонент, подобный тому, что используется в iPhone, с помощью HTML и CSS, без использования JavaScript. Для этого можно воспользоваться элементами формы и псевдоклассами CSS для изменения внешнего вида в зависимости от состояния переключателя. Вот пример такой реализации:
// ```html
// <input type="checkbox" id="toggle" class="toggle-checkbox">
// <label for="toggle" class="toggle-label"></label>
// ```

// ```css
// .toggle-checkbox {
//   display: none; /* Скрываем фактический переключатель */
// }

// .toggle-label {
//   display: inline-block;
//   width: 50px; /* Размер переключателя */
//   height: 30px;
//   background-color: #ccc; /* Цвет фона */
//   border-radius: 15px; /* Округление краев */
//   position: relative;
//   cursor: pointer;
// }

// .toggle-label::before {
//   content: '';
//   display: block;
//   width: 26px; /* Размер ползунка */
//   height: 26px;
//   background-color: #fff; /* Цвет ползунка */
//   border-radius: 50%; /* Округление краев ползунка */
//   position: absolute;
//   top: 50%;
//   transform: translateY(-50%);
//   left: 2px; /* Начальное положение ползунка */
//   transition: left 0.2s; /* Анимация при изменении состояния */
// }

// .toggle-checkbox:checked + .toggle-label::before {
//   left: calc(100% - 28px); /* Положение ползунка в положении "включено" */
// }
// ```
// Этот код создает стилизованный переключатель, который изменяет свое состояние при щелчке на него. При этом используются скрытый фактический чекбокс и псевдоэлементы CSS для создания внешнего вида переключателя и его ползунка.
// -----
// ⋙ ❍ Напишите функцию Sleep (ms), останавливающую выполнение async-функции на заданный промежуток времени? ✔
// Для реализации функции `sleep(ms)` в асинхронном контексте можно воспользоваться промисами и функцией `setTimeout()`, чтобы приостановить выполнение асинхронной функции на определенное количество миллисекунд. Вот пример реализации этой функции:
// ```javascript
// function sleep(ms) {
//   return new Promise(resolve => setTimeout(resolve, ms));
// }

// // Пример использования:
// async function example() {
//   console.log('Начало выполнения');
//   await sleep(2000); // Приостанавливаем выполнение на 2 секунды
//   console.log('Прошло 2 секунды');
// }

// example();
// ```
// Эта функция `sleep(ms)` возвращает промис, который будет выполнен после указанного количества миллисекунд. При использовании в асинхронной функции с помощью `await` выполнение будет приостановлено до завершения указанного времени.
// -----
// ⋙ ❍ Реализуйте один из методов массива (например, splice)? ✔
// `splice()` позволяет изменять содержимое массива, удаляя существующие элементы и/или добавляя новые элементы на их место. Вот простая реализация этого метода:
// ```javascript
// Array.prototype.customSplice = function(start, deleteCount, ...items) {
//   // Проверка наличия параметра start
//   if (start < 0) {
//     start = Math.max(this.length + start, 0);
//   }

//   const deletedItems = [];

//   // Удаление элементов из массива
//   const removeCount = Math.min(deleteCount, this.length - start);
//   for (let i = 0; i < removeCount; i++) {
//     const index = start + i;
//     deletedItems.push(this[index]);
//     // Сдвигаем все элементы после удаленного налево
//     for (let j = index; j < this.length - 1; j++) {
//       this[j] = this[j + 1];
//     }
//     // Удаляем последний элемент
//     this.length--;
//   }

//   // Добавление новых элементов в массив
//   const len = this.length;
//   const numNewElements = items.length;
//   const numMoveElements = len - start;
//   this.length = len + numNewElements - removeCount;
//   for (let i = len - 1; i >= start; i--) {
//     this[i + numNewElements - removeCount] = this[i];
//   }
//   for (let i = 0; i < numNewElements; i++) {
//     this[start + i] = items[i];
//   }

//   return deletedItems;
// };

// // Пример использования:
// const arr = [1, 2, 3, 4, 5];
// const deleted = arr.customSplice(2, 2, 'a', 'b', 'c');
// console.log('Массив после splice:', arr); // [1, 2, "a", "b", "c", 5]
// console.log('Удаленные элементы:', deleted); // [3, 4]
// ```
// Эта реализация `customSplice()` принимает три аргумента: `start` (индекс, с которого начинается удаление/вставка), `deleteCount` (количество удаляемых элементов) и `items` (элементы для вставки). Метод изменяет исходный массив и возвращает массив удаленных элементов.
// -----
// ⋙ ❍ Напишите функцию с RegExp для нахождения всех HTML-ссылок в строке? ✔
// Для нахождения всех HTML-ссылок в строке можно использовать регулярное выражение, которое будет соответствовать шаблону HTML-ссылки. Вот пример функции с регулярным выражением для этой задачи:
// ```javascript
// function findHTMLLinks(text) {
//   const regex = /<a\s+(?:[^>]*?\s+)?href="([^"]*)"/gi;
//   const links = [];
//   let match;

//   while ((match = regex.exec(text)) !== null) {
//     links.push(match[1]);
//   }

//   return links;
// }

// // Пример использования:
// const text = '<a href="https://example.com">Example</a> <a href="https://google.com">Google</a>';
// const links = findHTMLLinks(text);
// console.log(links); // ["https://example.com", "https://google.com"]
// ```
// Это регулярное выражение ищет все совпадения с шаблоном HTML-ссылки в тексте. Затем функция извлекает значения атрибута `href` из каждого совпадения и добавляет их в массив `links`.
// -----
// ⋙ ❍ Реализуйте функцию, которая исполнит callback для всех элементов определенной ветви DOM-дерева? ✔
// Для выполнения этой задачи можно использовать рекурсивный обход DOM-дерева, чтобы найти все элементы ветви и вызвать callback для каждого из них. Вот пример реализации такой функции:
// ```javascript
// function executeCallbackForBranch(rootElement, callback) {
//   // Функция для рекурсивного обхода DOM-дерева
//   function traverse(element) {
//     // Вызываем callback для текущего элемента
//     callback(element);

//     // Рекурсивно обходим дочерние элементы
//     for (let i = 0; i < element.children.length; i++) {
//       traverse(element.children[i]);
//     }
//   }

//   // Начинаем обход с корневого элемента
//   traverse(rootElement);
// }

// // Пример использования:
// // Предположим, у нас есть корневой элемент #root
// const rootElement = document.getElementById('root');

// // Callback функция, которая добавляет класс "highlight" к каждому элементу
// function highlightElement(element) {
//   element.classList.add('highlight');
// }

// // Вызываем функцию для выполнения callback для всех элементов ветви
// executeCallbackForBranch(rootElement, highlightElement);
// ```
// Этот код рекурсивно обходит все дочерние элементы начиная с заданного корневого элемента `rootElement` и вызывает переданный `callback` для каждого элемента ветви. В данном примере `highlightElement` добавляет класс "highlight" к каждому найденному элементу.
// -----
// ⋙ ❍ Реализуйте таблицу с виртуальным скроллом? ✔︎
// Для создания таблицы с виртуальным скроллом в React можно воспользоваться библиотеками или реализовать это самостоятельно. Вот пример простой реализации таблицы с виртуальным скроллом без использования сторонних библиотек:
// ```javascript
// import React, { useState, useEffect, useRef } from 'react';

// const VirtualizedTable = ({ data, rowHeight, visibleRowCount }) => {
//   const [startIndex, setStartIndex] = useState(0);
//   const tableRef = useRef();

//   const handleScroll = () => {
//     const scrollTop = tableRef.current.scrollTop;
//     const startIndex = Math.floor(scrollTop / rowHeight);
//     setStartIndex(startIndex);
//   };

//   useEffect(() => {
//     if (tableRef.current) {
//       tableRef.current.addEventListener('scroll', handleScroll);
//       return () => {
//         tableRef.current.removeEventListener('scroll', handleScroll);
//       };
//     }
//   }, []);

//   const visibleData = data.slice(startIndex, startIndex + visibleRowCount);

//   return (
//     <div style={{ height: `${rowHeight * visibleRowCount}px`, overflow: 'auto' }} ref={tableRef}>
//       <table>
//         <thead>
//           <tr>
//             <th>Name</th>
//             <th>Age</th>
//             <th>Email</th>
//           </tr>
//         </thead>
//         <tbody>
//           {visibleData.map((item, index) => (
//             <tr key={index}>
//               <td>{item.name}</td>
//               <td>{item.age}</td>
//               <td>{item.email}</td>
//             </tr>
//           ))}
//         </tbody>
//       </table>
//     </div>
//   );
// };

// export default VirtualizedTable;
// ```
// Этот компонент принимает данные `data`, высоту строки `rowHeight` и количество видимых строк `visibleRowCount`. Он использует состояние для отслеживания индекса начальной строки, а затем рендерит только видимые строки на основе этого индекса и количества видимых строк. Когда пользователь прокручивает таблицу, обработчик `handleScroll` обновляет начальный индекс в соответствии с положением прокрутки.
// -----
// ⋙ ❍ Реализуйте функцию преобразования URL query строки в JSON? ✔
// const inData = "user.name.firstname=Bob&user.name.lastname=Smith&user.favoritecolor=Light%20Blue";
// function queryObjectify(arg) {
// // ??
// }
// queryObjectify(inData)
// /* Результатом виконання для вхідного рядка, повинен бути наступний об’єкт
// {
//   'user': {
//     'name': {
//       'firstname': 'Bob',
//       'lastname': 'Smith'
//     },
//     'favoritecolor': 'Light Blue'
//   }
// };
// */
// Для преобразования URL-запроса в JSON можно использовать циклы и разбиение строки на подстроки. Вот один из способов реализации этой функции:
// ```javascript
// const inData = "user.name.firstname=Bob&user.name.lastname=Smith&user.favoritecolor=Light%20Blue";

// function queryObjectify(arg) {
//     const result = {};

//     // Разбить строку по символу '&', чтобы получить отдельные пары ключ-значение
//     const pairs = arg.split('&');

//     pairs.forEach(pair => {
//         // Разбить каждую пару по символу '=', чтобы получить ключ и значение
//         const [key, value] = pair.split('=');

//         // Разделить ключ на уровни объекта и создать структуру JSON
//         const keys = key.split('.');

//         let current = result;
//         keys.forEach((key, index) => {
//             // Проверить, существует ли уже объект с этим ключом
//             if (!current[key]) {
//                 // Если объект не существует, создать новый объект или массив
//                 current[key] = index === keys.length - 1 ? decodeURIComponent(value) : {};
//             }
//             // Перейти к следующему уровню объекта
//             current = current[key];
//         });
//     });

//     return result;
// }

// console.log(queryObjectify(inData));
// ```
// Эта функция разбивает URL-запрос на отдельные пары ключ-значение, затем разбивает каждую пару на ключи и значения. Далее она создает структуру JSON, соответствующую ключам и значениям. При этом значения URL-кодируются с помощью `decodeURIComponent()`, чтобы преобразовать закодированные символы (%20 и др.) обратно в их исходное представление.
// -----
// ⋙ ❍ Реализуйте функцию поиска пересечения двух массивов? ✔
// const first = [1, 2, 3, 4];
// const second = [3, 4, 5, 6];
// function intersection (a, b) {
// // ??
// }
// intersection(first, second) // -> [3, 4]
// Для поиска пересечения двух массивов можно воспользоваться методом `filter()`, который позволяет отфильтровать элементы массива на основе определенного условия. Вот как можно реализовать функцию поиска пересечения двух массивов:
// ```javascript
// const first = [1, 2, 3, 4];
// const second = [3, 4, 5, 6];

// function intersection(a, b) {
//     // Отфильтровать элементы первого массива, оставив только те, которые также присутствуют во втором массиве
//     return a.filter(item => b.includes(item));
// }

// console.log(intersection(first, second)); // -> [3, 4]
// ```
// Эта функция принимает два массива в качестве аргументов и возвращает новый массив, содержащий элементы, которые присутствуют и в первом, и во втором массиве.
// -----
// ⋙ ❍ Реализуйте функцию/класс для генерации HTML? ✔
// const HTMLConstruct = {};
// HTMLConstruct.span('foo'); // -> <span>foo</span>
// HTMLConstruct.div.span('bar'); // -> <div><span>bar</span></div>
// HTMLConstruct.div.p(
// HTMLConstruct.span('bar'),
// HTMLConstruct.div.span('baz')
// ); // -> <div><p><span>bar</span><span>baz</span></p></div>
// --------------------------------------------------------------------------------------------
('use strict');

